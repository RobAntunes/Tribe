This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
commands/
  annotationCommands.ts
  changeCommands.ts
  checkpointCommands.ts
  conflictCommands.ts
  historyCommands.ts
  implementationCommands.ts
common/
  log/
    logging.ts
  constants.ts
  python.ts
  server.ts
  settings.ts
  setup.ts
  utilities.ts
  vscodeapi.ts
models/
  errorHandling.ts
  types.ts
services/
  diffService.ts
  storageService.ts
test/
  python_tests/
    lsp_test_client/
      __init__.py
      constants.py
      defaults.py
      session.py
      utils.py
    test_data/
      sample1/
        sample.py
        sample.unformatted
    __init__.py
    requirements.in
    requirements.txt
    test_server.py
  suite/
    extension.test.ts
  diffManager.test.ts
themes/
  default.json
commands.ts
config.ts
diffUtils.ts
errorHandling.ts
extension.ts
storage.ts

================================================================
Files
================================================================

================
File: commands/annotationCommands.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import { StorageService } from '../services/storageService';
import { CreateAnnotationPayload, AddReplyPayload } from '../models/types';
import { errorWrapper } from '../errorHandling';
import { COMMANDS, API_ENDPOINTS } from '../config';

/**
 * Register annotation management commands
 * @param context Extension context
 */
export function registerAnnotationCommands(context: vscode.ExtensionContext): void {
	// Initialize services
	const storageService = StorageService.getInstance(context);

	// Register commands
	const commands = [
		vscode.commands.registerCommand(
			COMMANDS.CREATE_ANNOTATION,
			errorWrapper(
				async (payload: CreateAnnotationPayload): Promise<any> => {
					console.log('Creating annotation:', payload.content);

					try {
						// Create an annotation
						const annotation = {
							id: `annotation-${Date.now()}`,
							timestamp: new Date().toISOString(),
							filePath: payload.filePath,
							lineNumber: payload.lineNumber,
							content: payload.content,
							author: payload.author || 'User',
							replies: [],
							resolved: false,
							tags: payload.tags || [],
						};

						// Save the annotation
						await storageService.saveAnnotation(annotation);

						// Show a success message
						vscode.window.showInformationMessage(
							`Annotation created for ${payload.filePath}:${payload.lineNumber}`,
						);

						return {
							annotation,
							success: true,
						};
					} catch (error) {
						console.error('Error creating annotation:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'CREATE_ANNOTATION',
				'Create an annotation for a specific line in a file',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.GET_ANNOTATIONS,
			errorWrapper(
				async (filePath?: string): Promise<any[]> => {
					// Get all annotations from storage
					const annotations = await storageService.getAnnotations();

					// If filePath is provided, filter annotations for that file
					if (filePath) {
						return annotations.filter((a) => a.filePath === filePath);
					}

					return annotations;
				},
				'GET_ANNOTATIONS',
				'Get all annotations or annotations for a specific file',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.DELETE_ANNOTATION,
			errorWrapper(
				async (annotationId: string): Promise<boolean> => {
					console.log(`Deleting annotation: ${annotationId}`);

					// Delete the annotation from storage
					await storageService.deleteAnnotation(annotationId);

					// Show a success message
					vscode.window.showInformationMessage(`Annotation ${annotationId} deleted`);

					return true;
				},
				'DELETE_ANNOTATION',
				'Delete an annotation',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.RESOLVE_ANNOTATION,
			errorWrapper(
				async (annotationId: string): Promise<boolean> => {
					console.log(`Resolving annotation: ${annotationId}`);

					try {
						// Get all annotations
						const annotations = await storageService.getAnnotations();

						// Find the annotation to resolve
						const annotationIndex = annotations.findIndex((a) => a.id === annotationId);

						if (annotationIndex === -1) {
							throw new Error(`Annotation ${annotationId} not found`);
						}

						// Mark the annotation as resolved
						annotations[annotationIndex].resolved = true;

						// Save the updated annotation
						await storageService.saveAnnotation(annotations[annotationIndex]);

						// Show a success message
						vscode.window.showInformationMessage(`Annotation ${annotationId} resolved`);

						return true;
					} catch (error) {
						console.error(`Error resolving annotation: ${error}`);
						vscode.window.showErrorMessage(`Failed to resolve annotation: ${error}`);
						return false;
					}
				},
				'RESOLVE_ANNOTATION',
				'Mark an annotation as resolved',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.ADD_REPLY,
			errorWrapper(
				async (payload: AddReplyPayload): Promise<any> => {
					console.log(`Adding reply to annotation: ${payload.parentId}`);

					try {
						// Add reply to the annotation
						await storageService.addReplyToAnnotation(payload.parentId, {
							id: `reply-${Date.now()}`,
							timestamp: new Date().toISOString(),
							content: payload.content,
							author: payload.author || 'User',
						});

						// Show a success message
						vscode.window.showInformationMessage(`Reply added to annotation ${payload.parentId}`);

						return {
							success: true,
						};
					} catch (error) {
						console.error('Error adding reply:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'ADD_REPLY',
				'Add a reply to an annotation',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.SHOW_ANNOTATIONS_IN_FILE,
			errorWrapper(
				async (): Promise<void> => {
					// Get the active text editor
					const editor = vscode.window.activeTextEditor;

					if (!editor) {
						vscode.window.showWarningMessage('No active editor found');
						return;
					}

					const filePath = editor.document.uri.fsPath;

					// Get annotations for this file
					const annotations = (await vscode.commands.executeCommand(
						COMMANDS.GET_ANNOTATIONS,
						filePath,
					)) as any[];

					if (annotations.length === 0) {
						vscode.window.showInformationMessage('No annotations found for this file');
						return;
					}

					// Create decorations for annotations
					const decorationType = vscode.window.createTextEditorDecorationType({
						backgroundColor: 'rgba(255, 220, 0, 0.2)',
						isWholeLine: true,
						after: {
							contentText: 'ðŸ’¬',
							margin: '0 0 0 1em',
						},
					});

					// Apply decorations
					const decorations = annotations.map((a) => {
						const line = a.lineNumber;
						const range = new vscode.Range(new vscode.Position(line, 0), new vscode.Position(line, 0));
						return { range };
					});

					editor.setDecorations(decorationType, decorations);

					// Show a message with the count
					vscode.window.showInformationMessage(`Found ${annotations.length} annotations in this file`);
				},
				'SHOW_ANNOTATIONS_IN_FILE',
				'Show annotations in the current file',
			),
		),
	];

	// Add commands to context subscriptions
	context.subscriptions.push(...commands);
}

================
File: commands/changeCommands.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import { StorageService } from '../services/storageService';
import { DiffService } from '../services/diffService';
import { ApplyChangesPayload, CreateChangeGroupPayload } from '../models/types';
import { errorWrapper } from '../errorHandling';
import { COMMANDS, API_ENDPOINTS } from '../config';

/**
 * Register change management commands
 * @param context Extension context
 */
export function registerChangeCommands(context: vscode.ExtensionContext): void {
	// Initialize services
	const storageService = StorageService.getInstance(context);
	const diffService = DiffService.getInstance();

	// Register commands
	const commands = [
		vscode.commands.registerCommand(
			COMMANDS.APPLY_CHANGES,
			errorWrapper(
				async (payload: ApplyChangesPayload): Promise<boolean> => {
					console.log('Applying changes:', payload);

					try {
						// Process file modifications
						if (payload.files.modify && Object.keys(payload.files.modify).length > 0) {
							for (const path in payload.files.modify) {
								// Get the original content if the file exists
								const originalContent = diffService.getFileContent(path) || '';

								// Generate a FileChange object with hunks
								const fileChange = diffService.generateFileChange(
									path,
									originalContent,
									payload.files.modify[path],
								);

								// Apply the file change
								if (!diffService.applyFileChange(fileChange)) {
									console.error(`Failed to modify file: ${path}`);
									return false;
								}
							}
						}

						// Process file creations
						if (payload.files.create && Object.keys(payload.files.create).length > 0) {
							for (const path in payload.files.create) {
								// Generate a FileChange object
								const fileChange = {
									path: path,
									content: payload.files.create[path],
									type: 'create' as const,
								};

								// Apply the file change
								if (!diffService.applyFileChange(fileChange)) {
									console.error(`Failed to create file: ${path}`);
									return false;
								}
							}
						}

						// Process file deletions
						if (payload.files.delete && payload.files.delete.length > 0) {
							for (const path of payload.files.delete) {
								// Delete the file
								if (!diffService.deleteFile(path)) {
									console.error(`Failed to delete file: ${path}`);
									return false;
								}
							}
						}

						return true;
					} catch (error) {
						console.error('Error applying changes:', error);
						throw error;
					}
				},
				'APPLY_CHANGES',
				'Apply code changes to workspace files',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.CREATE_CHANGE_GROUP,
			errorWrapper(
				async (payload: CreateChangeGroupPayload): Promise<string> => {
					console.log(`Creating change group: ${payload.title}`);

					// Generate a unique ID for the change group
					const groupId = `group-${Date.now()}`;

					// Create file changes with hunks for modified files
					const modifyChanges = await Promise.all(
						(payload.filesToModify || []).map(async (file: { path: string; content: string }) => {
							// Get the original content if the file exists
							const originalContent = diffService.getFileContent(file.path) || '';

							// Generate a FileChange object with hunks
							return {
								...diffService.generateFileChange(file.path, originalContent, file.content),
								type: 'modify' as const,
							};
						}),
					);

					// Create file changes for new files
					const createChanges = (payload.filesToCreate || []).map(
						(file: { path: string; content: string }) => ({
							path: file.path,
							content: file.content,
							type: 'create' as const,
							explanation: `Created new file: ${file.path}`,
						}),
					);

					// Create delete file changes
					const deleteChanges = (payload.filesToDelete || []).map((path: string) => ({
						path,
						content: '',
						type: 'delete' as const,
					}));

					// Create the change group
					const changeGroup = {
						id: groupId,
						title: payload.title,
						description: payload.description,
						agentId: payload.agentId,
						agentName: payload.agentName,
						timestamp: new Date().toISOString(),
						files: [...modifyChanges, ...createChanges, ...deleteChanges],
						status: 'pending' as const,
					};

					// Save the change group
					await storageService.saveChangeGroup(changeGroup);

					return groupId;
				},
				'CREATE_CHANGE_GROUP',
				'Create a change group from a set of changes',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.ACCEPT_CHANGE_GROUP,
			errorWrapper(
				async (groupId: string): Promise<boolean> => {
					console.log('Accepting change group:', groupId);

					// Get the change group from storage
					const group = await storageService.getChangeGroup(groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return false;
					}

					// Apply all changes in the group
					const payload: ApplyChangesPayload = {
						files: {
							modify: {},
							create: {},
							delete: [],
						},
					};

					// Categorize files by type
					for (const file of group.files) {
						if (file.type === 'modify') {
							payload.files.modify[file.path] = file.content;
						} else if (file.type === 'create') {
							payload.files.create[file.path] = file.content;
						} else if (file.type === 'delete') {
							payload.files.delete.push(file.path);
						}
					}

					const result = await vscode.commands.executeCommand(COMMANDS.APPLY_CHANGES, payload);

					// If successful, remove the group from storage
					if (result) {
						await storageService.deleteChangeGroup(groupId);
					}

					return !!result;
				},
				'ACCEPT_CHANGE_GROUP',
				'Accept all changes in a change group',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.REJECT_CHANGE_GROUP,
			errorWrapper(
				async (groupId: string): Promise<boolean> => {
					console.log('Rejecting change group:', groupId);

					// Remove the group from storage
					await storageService.deleteChangeGroup(groupId);
					return true;
				},
				'REJECT_CHANGE_GROUP',
				'Reject all changes in a change group',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.ACCEPT_FILE,
			errorWrapper(
				async (
					groupId: string,
					filePath: string,
					fileType: 'modify' | 'create' | 'delete',
				): Promise<boolean> => {
					console.log(`Accepting file: ${filePath} (${fileType}) from group: ${groupId}`);

					// Get the change group from storage
					const group = await storageService.getChangeGroup(groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return false;
					}

					// Find the file in the appropriate list
					let fileToApply;
					let result = false;

					if (fileType === 'modify') {
						fileToApply = group.files.find((f) => f.path === filePath && f.type === 'modify');
						if (fileToApply) {
							const payload: ApplyChangesPayload = {
								files: {
									modify: { [fileToApply.path]: fileToApply.content },
									create: {},
									delete: [],
								},
							};
							result = await vscode.commands.executeCommand(COMMANDS.APPLY_CHANGES, payload);
						}
					} else if (fileType === 'create') {
						fileToApply = group.files.find((f) => f.path === filePath && f.type === 'create');
						if (fileToApply) {
							const payload: ApplyChangesPayload = {
								files: {
									modify: {},
									create: { [fileToApply.path]: fileToApply.content },
									delete: [],
								},
							};
							result = await vscode.commands.executeCommand(COMMANDS.APPLY_CHANGES, payload);
						}
					} else if (fileType === 'delete') {
						fileToApply = group.files.find((f) => f.path === filePath && f.type === 'delete');
						if (fileToApply) {
							const payload: ApplyChangesPayload = {
								files: {
									modify: {},
									create: {},
									delete: [fileToApply.path],
								},
							};
							result = await vscode.commands.executeCommand(COMMANDS.APPLY_CHANGES, payload);
						}
					}

					// If the group is now empty, remove it from storage
					if (group.files.length === 0) {
						await storageService.deleteChangeGroup(groupId);
					} else {
						// Otherwise, update the group in storage
						await storageService.saveChangeGroup(group);
					}

					return result;
				},
				'ACCEPT_FILE',
				'Accept changes for a specific file',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.REJECT_FILE,
			errorWrapper(
				async (
					groupId: string,
					filePath: string,
					fileType: 'modify' | 'create' | 'delete',
				): Promise<boolean> => {
					console.log(`Rejecting file: ${filePath} (${fileType}) from group: ${groupId}`);

					// Get the change group from storage
					const group = await storageService.getChangeGroup(groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return false;
					}

					// Remove the file from the appropriate list
					group.files = group.files.filter((file) => {
						if (fileType === 'modify') {
							return !(file.path === filePath && file.type === 'modify');
						} else if (fileType === 'create') {
							return !(file.path === filePath && file.type === 'create');
						} else if (fileType === 'delete') {
							return !(file.path === filePath && file.type === 'delete');
						}
						return true;
					});

					// If the group is now empty, remove it from storage
					if (group.files.length === 0) {
						await storageService.deleteChangeGroup(groupId);
					} else {
						// Otherwise, update the group in storage
						await storageService.saveChangeGroup(group);
					}

					return true;
				},
				'REJECT_FILE',
				'Reject changes for a specific file',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.MODIFY_CHANGE,
			errorWrapper(
				async (groupId: string, filePath: string, newContent: string): Promise<boolean> => {
					console.log(`Modifying change: ${filePath} in group: ${groupId}`);

					// Get the change group from storage
					const group = await storageService.getChangeGroup(groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return false;
					}

					// Find the file in the appropriate list and update its content
					let fileUpdated = false;

					// Find the file and update its content
					const fileIndex = group.files.findIndex(
						(f) => f.path === filePath && (f.type === 'modify' || f.type === 'create'),
					);
					if (fileIndex >= 0) {
						group.files[fileIndex].content = newContent;
						fileUpdated = true;
					}

					// If the file was updated, save the group to storage
					if (fileUpdated) {
						await storageService.saveChangeGroup(group);
					}

					return fileUpdated;
				},
				'MODIFY_CHANGE',
				'Modify content of a pending change',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.REQUEST_EXPLANATION,
			errorWrapper(
				async (groupId: string, filePath: string): Promise<string> => {
					console.log(`Requesting explanation for: ${filePath} in group: ${groupId}`);

					// Get the change group from storage
					const group = await storageService.getChangeGroup(groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return "Couldn't find the file to explain.";
					}

					// Find the file in the appropriate list
					let fileToExplain = group.files.find((f) => f.path === filePath);
					let fileType: 'modify' | 'create' | 'delete' = 'modify';

					if (fileToExplain) {
						fileType = fileToExplain.type;
					} else {
						return "Couldn't find the file to explain.";
					}

					// If the file already has an explanation, return it
					if (fileToExplain && fileToExplain.explanation) {
						return fileToExplain.explanation;
					}

					// Otherwise, generate an explanation
					let explanation = '';
					if (fileType === 'modify') {
						explanation = `This change to ${filePath} implements the requested functionality by:
                    
1. Adding necessary imports and dependencies
2. Implementing the core logic for the feature
3. Ensuring proper error handling and edge cases
4. Optimizing performance where possible
5. Adding appropriate documentation

The key changes include updating function signatures, adding error handling, and improving the overall code structure.`;
					} else if (fileType === 'create') {
						explanation = `This new file ${filePath} is created to:
                    
1. Implement a new feature or component
2. Provide utility functions for the application
3. Enhance the overall architecture
4. Support the existing codebase with additional functionality
5. Improve maintainability and code organization

The file contains all necessary imports, proper error handling, and comprehensive documentation.`;
					} else if (fileType === 'delete') {
						explanation = `The file ${filePath} is being deleted because:
                    
1. Its functionality has been deprecated
2. It has been replaced by a more efficient implementation
3. It's no longer needed in the current architecture
4. Its functionality has been merged into other files
5. It contained outdated or redundant code`;
					}

					// If we found a file to explain, update its explanation
					if (fileToExplain) {
						fileToExplain.explanation = explanation;
						await storageService.saveChangeGroup(group);
					}

					return explanation;
				},
				'REQUEST_EXPLANATION',
				'Request explanation for a specific file change',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.GET_PENDING_CHANGES,
			errorWrapper(
				async (): Promise<any[]> => {
					// Get all change groups from storage
					return storageService.getChangeGroups();
				},
				'GET_PENDING_CHANGES',
				'Get all pending changes',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.VIEW_DIFF,
			errorWrapper(
				async (originalContent: string, newContent: string, title: string): Promise<void> => {
					// Use the DiffService to show the diff
					await diffService.showDiff(originalContent, newContent, title);
				},
				'VIEW_DIFF',
				'View diff between original and new content',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.GENERATE_HUNKS,
			errorWrapper(
				async (filePath: string, originalContent: string, modifiedContent: string): Promise<any[]> => {
					console.log(`Generating hunks for file: ${filePath}`);

					// Use DiffService to generate hunks
					return diffService.generateHunks(originalContent, modifiedContent);
				},
				'GENERATE_HUNKS',
				'Generate hunks for a file change',
			),
		),
	];

	// Add commands to context subscriptions
	context.subscriptions.push(...commands);
}

================
File: commands/checkpointCommands.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import { StorageService } from '../services/storageService';
import { DiffService } from '../services/diffService';
import { CreateCheckpointPayload, CreateSubCheckpointPayload, RevertToSubCheckpointPayload } from '../models/types';
import { errorWrapper } from '../errorHandling';
import { COMMANDS, API_ENDPOINTS } from '../config';

/**
 * Register checkpoint management commands
 * @param context Extension context
 */
export function registerCheckpointCommands(context: vscode.ExtensionContext): void {
	// Initialize services
	const storageService = StorageService.getInstance(context);
	const diffService = DiffService.getInstance();

	// Register commands
	const commands = [
		vscode.commands.registerCommand(
			COMMANDS.CREATE_CHECKPOINT,
			errorWrapper(
				async (payload: CreateCheckpointPayload): Promise<any> => {
					console.log('Creating checkpoint:', payload.description);

					try {
						// Create a snapshot of the current workspace
						const snapshotData = await storageService.createWorkspaceSnapshot();

						// Create a checkpoint
						const checkpoint = {
							id: `checkpoint-${Date.now()}`,
							timestamp: new Date().toISOString(),
							description: payload.description,
							changes: {
								modified: 0,
								created: 0,
								deleted: 0,
							},
							snapshotPath: '',
							changeGroups: payload.changeGroups || [],
						};

						// Save the checkpoint
						await storageService.saveCheckpoint(checkpoint, snapshotData);

						return {
							checkpoint,
							success: true,
						};
					} catch (error) {
						console.error('Error creating checkpoint:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'CREATE_CHECKPOINT',
				'Create a checkpoint of the current workspace state',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.GET_CHECKPOINTS,
			errorWrapper(
				async (): Promise<any[]> => {
					// Get all checkpoints from storage
					return storageService.getCheckpoints();
				},
				'GET_CHECKPOINTS',
				'Get all checkpoints',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.RESTORE_CHECKPOINT,
			errorWrapper(
				async (checkpointId: string): Promise<boolean> => {
					console.log(`Restoring checkpoint: ${checkpointId}`);

					try {
						// Get the checkpoint snapshot
						const snapshot = await storageService.getCheckpointSnapshot(checkpointId);

						// Restore the workspace from the snapshot
						await storageService.restoreWorkspaceFromSnapshot(snapshot);

						return true;
					} catch (error) {
						console.error(`Error restoring checkpoint: ${error}`);
						return false;
					}
				},
				'RESTORE_CHECKPOINT',
				'Restore workspace to a checkpoint',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.DELETE_CHECKPOINT,
			errorWrapper(
				async (checkpointId: string): Promise<boolean> => {
					console.log(`Deleting checkpoint: ${checkpointId}`);

					// Delete the checkpoint from storage
					await storageService.deleteCheckpoint(checkpointId);
					return true;
				},
				'DELETE_CHECKPOINT',
				'Delete a checkpoint',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.VIEW_CHECKPOINT_DIFF,
			errorWrapper(
				async (checkpointId: string): Promise<void> => {
					console.log(`Viewing diff for checkpoint: ${checkpointId}`);

					try {
						// Get the checkpoint snapshot
						const checkpointSnapshot = await storageService.getCheckpointSnapshot(checkpointId);

						// Create a snapshot of the current workspace
						const currentSnapshot = await storageService.createWorkspaceSnapshot();

						// Calculate the diff between the two snapshots
						const diff = storageService.calculateDiff(checkpointSnapshot, currentSnapshot);

						// Show a summary of the diff
						const message = `Changes since checkpoint:
- Modified: ${diff.modified.length} files
- Created: ${diff.created.length} files
- Deleted: ${diff.deleted.length} files`;

						vscode.window.showInformationMessage(message);

						// If there are modified files, show the first one
						if (diff.modified.length > 0) {
							const filePath = diff.modified[0];
							const originalContent = checkpointSnapshot[filePath] || '';
							const newContent = currentSnapshot[filePath] || '';

							// Use DiffService to show the diff
							await diffService.showDiff(
								originalContent,
								newContent,
								`Diff for ${filePath} (Checkpoint vs Current)`,
							);
						}
					} catch (error) {
						console.error(`Error viewing checkpoint diff: ${error}`);
						vscode.window.showErrorMessage(`Failed to view checkpoint diff: ${error}`);
					}
				},
				'VIEW_CHECKPOINT_DIFF',
				'View diff between checkpoint and current state',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.CREATE_SUB_CHECKPOINT,
			errorWrapper(
				async (payload: CreateSubCheckpointPayload): Promise<any> => {
					console.log('Creating sub-checkpoint for:', payload.parentCheckpointId);

					try {
						const subCheckpoint = await storageService.createSubCheckpoint(
							payload.parentCheckpointId,
							payload.description,
							Array.isArray(payload.changes) ? payload.changes : [],
						);

						return {
							subCheckpoint,
							success: true,
						};
					} catch (error) {
						console.error('Error creating sub-checkpoint:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'CREATE_SUB_CHECKPOINT',
				'Create a sub-checkpoint',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.REVERT_TO_SUB_CHECKPOINT,
			errorWrapper(
				async (payload: RevertToSubCheckpointPayload): Promise<any> => {
					console.log('Reverting to sub-checkpoint:', payload.subCheckpointId);

					try {
						// Get the parent checkpoint
						const checkpoints = await storageService.getCheckpoints();
						const parentCheckpoint = checkpoints.find((c) => c.id === payload.checkpointId);

						if (!parentCheckpoint) {
							throw new Error(`Parent checkpoint ${payload.checkpointId} not found`);
						}

						// Find the sub-checkpoint
						const subCheckpoint = parentCheckpoint.subCheckpoints?.find(
							(sc) => sc.id === payload.subCheckpointId,
						);

						if (!subCheckpoint) {
							throw new Error(`Sub-checkpoint ${payload.subCheckpointId} not found`);
						}

						// Get the parent checkpoint snapshot
						const snapshot = await storageService.getCheckpointSnapshot(payload.checkpointId);

						// Restore the workspace from the snapshot
						await storageService.restoreWorkspaceFromSnapshot(snapshot);

						return {
							success: true,
						};
					} catch (error) {
						console.error('Error reverting to sub-checkpoint:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'REVERT_TO_SUB_CHECKPOINT',
				'Revert to a sub-checkpoint',
			),
		),
	];

	// Add commands to context subscriptions
	context.subscriptions.push(...commands);
}

================
File: commands/conflictCommands.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import { StorageService } from '../services/storageService';
import { DiffService } from '../services/diffService';
import { CreateConflictPayload, ResolveConflictPayload } from '../models/types';
import { errorWrapper } from '../errorHandling';
import { COMMANDS, API_ENDPOINTS } from '../config';

/**
 * Register conflict management commands
 * @param context Extension context
 */
export function registerConflictCommands(context: vscode.ExtensionContext): void {
	// Initialize services
	const storageService = StorageService.getInstance(context);
	const diffService = DiffService.getInstance();

	// Register commands
	const commands = [
		vscode.commands.registerCommand(
			COMMANDS.CREATE_CONFLICT,
			errorWrapper(
				async (payload: CreateConflictPayload): Promise<any> => {
					console.log('Creating conflict:', payload.title);

					try {
						// Create a conflict
						const conflict = {
							id: `conflict-${Date.now()}`,
							timestamp: new Date().toISOString(),
							title: payload.title,
							description: payload.description,
							filePath: payload.filePath,
							status: 'unresolved' as const,
							agentChanges: payload.agentChanges || [],
							userChanges: payload.userChanges || [],
							resolvedContent: null,
						};

						// Save the conflict
						await storageService.saveConflict(conflict);

						return {
							conflict,
							success: true,
						};
					} catch (error) {
						console.error('Error creating conflict:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'CREATE_CONFLICT',
				'Create a conflict record for a file',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.GET_CONFLICTS,
			errorWrapper(
				async (status?: string): Promise<any[]> => {
					// Get all conflicts from storage
					const conflicts = await storageService.getConflicts();

					// If status is provided, filter conflicts by status
					if (status) {
						return conflicts.filter((c) => c.status === status);
					}

					return conflicts;
				},
				'GET_CONFLICTS',
				'Get all conflicts or conflicts with a specific status',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.DELETE_CONFLICT,
			errorWrapper(
				async (conflictId: string): Promise<boolean> => {
					console.log(`Deleting conflict: ${conflictId}`);

					// Delete the conflict from storage
					await storageService.deleteConflict(conflictId);

					return true;
				},
				'DELETE_CONFLICT',
				'Delete a conflict',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.RESOLVE_CONFLICT,
			errorWrapper(
				async (payload: ResolveConflictPayload): Promise<any> => {
					console.log(`Resolving conflict: ${payload.conflictId}`);

					try {
						// Get the conflict
						const conflicts = await storageService.getConflicts();
						const conflictIndex = conflicts.findIndex((c) => c.id === payload.conflictId);

						if (conflictIndex === -1) {
							throw new Error(`Conflict ${payload.conflictId} not found`);
						}

						const conflict = conflicts[conflictIndex];

						// Update the conflict with the resolved content
						conflict.resolvedContent = payload.resolvedContent;
						conflict.status = 'resolved';

						// Save the conflict
						await storageService.saveConflict(conflict);

						// Apply the resolved content to the file
						await diffService.applyFileChange({
							path: conflict.filePath,
							content: payload.resolvedContent,
							type: 'modify',
						});

						// Show a success message
						vscode.window.showInformationMessage(
							`Conflict ${payload.conflictId} resolved and applied to ${conflict.filePath}`,
						);

						return {
							conflict,
							success: true,
						};
					} catch (error) {
						console.error('Error resolving conflict:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'RESOLVE_CONFLICT',
				'Resolve a conflict with custom content',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.RESOLVE_CONFLICT_WITH_AGENT,
			errorWrapper(
				async (conflictId: string): Promise<any> => {
					console.log(`Resolving conflict with agent changes: ${conflictId}`);

					try {
						// Get the conflict first
						const conflicts = await storageService.getConflicts();
						const conflict = conflicts.find((c) => c.id === conflictId);

						if (!conflict) {
							throw new Error(`Conflict ${conflictId} not found`);
						}

						// Resolve the conflict automatically using agent changes
						const resolvedChanges = await storageService.resolveConflictAutomatically(conflictId, 'agent');

						// Get the updated conflict after resolution
						const updatedConflicts = await storageService.getConflicts();
						const updatedConflict = updatedConflicts.find((c) => c.id === conflictId);

						if (updatedConflict && updatedConflict.resolvedContent) {
							// Apply the resolved content to the file
							await diffService.applyFileChange({
								path: updatedConflict.filePath,
								content: updatedConflict.resolvedContent,
								type: 'modify',
							});

							// Show a success message
							vscode.window.showInformationMessage(
								`Conflict ${conflictId} resolved with agent changes and applied to ${updatedConflict.filePath}`,
							);

							return {
								success: true,
								conflict: updatedConflict,
								changes: resolvedChanges,
							};
						} else {
							throw new Error('Failed to resolve conflict: No resolved content available');
						}
					} catch (error) {
						console.error('Error resolving conflict with agent changes:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'RESOLVE_CONFLICT_WITH_AGENT',
				'Resolve a conflict using agent changes',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.RESOLVE_CONFLICT_WITH_USER,
			errorWrapper(
				async (conflictId: string): Promise<any> => {
					console.log(`Resolving conflict with user changes: ${conflictId}`);

					try {
						// Get the conflict first
						const conflicts = await storageService.getConflicts();
						const conflict = conflicts.find((c) => c.id === conflictId);

						if (!conflict) {
							throw new Error(`Conflict ${conflictId} not found`);
						}

						// Resolve the conflict automatically using user changes
						const resolvedChanges = await storageService.resolveConflictAutomatically(conflictId, 'user');

						// Get the updated conflict after resolution
						const updatedConflicts = await storageService.getConflicts();
						const updatedConflict = updatedConflicts.find((c) => c.id === conflictId);

						if (updatedConflict && updatedConflict.resolvedContent) {
							// Apply the resolved content to the file
							await diffService.applyFileChange({
								path: updatedConflict.filePath,
								content: updatedConflict.resolvedContent,
								type: 'modify',
							});

							// Show a success message
							vscode.window.showInformationMessage(
								`Conflict ${conflictId} resolved with user changes and applied to ${updatedConflict.filePath}`,
							);

							return {
								success: true,
								conflict: updatedConflict,
								changes: resolvedChanges,
							};
						} else {
							throw new Error('Failed to resolve conflict: No resolved content available');
						}
					} catch (error) {
						console.error('Error resolving conflict with user changes:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'RESOLVE_CONFLICT_WITH_USER',
				'Resolve a conflict using user changes',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.VIEW_CONFLICT_DIFF,
			errorWrapper(
				async (conflictId: string): Promise<void> => {
					console.log(`Viewing diff for conflict: ${conflictId}`);

					try {
						// Get the conflict
						const conflicts = await storageService.getConflicts();
						const conflict = conflicts.find((c) => c.id === conflictId);

						if (!conflict) {
							throw new Error(`Conflict ${conflictId} not found`);
						}

						// Get the current file content
						let originalContent: string = '';
						try {
							const fileContent = await diffService.getFileContent(conflict.filePath);
							originalContent = fileContent || '';
						} catch (error) {
							console.error(`Error getting file content for ${conflict.filePath}:`, error);
							originalContent = '';
						}

						// Show a quick pick to select which diff to view
						const options = [
							{
								label: 'Agent Changes',
								description: 'View diff between original and agent changes',
								content: conflict.agentChanges.length > 0 ? conflict.agentChanges[0].content : '',
							},
							{
								label: 'User Changes',
								description: 'View diff between original and user changes',
								content: conflict.userChanges.length > 0 ? conflict.userChanges[0].content : '',
							},
						];

						if (conflict.status === 'resolved' && conflict.resolvedContent) {
							options.push({
								label: 'Resolved Content',
								description: 'View diff between original and resolved content',
								content: conflict.resolvedContent,
							});
						}

						const selectedOption = await vscode.window.showQuickPick(options, {
							placeHolder: 'Select which diff to view',
						});

						if (!selectedOption) {
							return;
						}

						// Show the diff
						await diffService.showDiff(
							originalContent,
							selectedOption.content,
							`Diff for ${conflict.filePath} (${selectedOption.label})`,
						);
					} catch (error) {
						console.error(`Error viewing conflict diff: ${error}`);
						vscode.window.showErrorMessage(`Failed to view conflict diff: ${error}`);
					}
				},
				'VIEW_CONFLICT_DIFF',
				'View diff for a conflict',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.MERGE_CONFLICT_CHANGES,
			errorWrapper(
				async (conflictId: string): Promise<any> => {
					console.log(`Merging changes for conflict: ${conflictId}`);

					try {
						// Get the conflict
						const conflicts = await storageService.getConflicts();
						const conflict = conflicts.find((c) => c.id === conflictId);

						if (!conflict) {
							throw new Error(`Conflict ${conflictId} not found`);
						}

						// Get the current file content
						let originalContent: string = '';
						try {
							const fileContent = await diffService.getFileContent(conflict.filePath);
							originalContent = fileContent || '';
						} catch (error) {
							console.error(`Error getting file content for ${conflict.filePath}:`, error);
							originalContent = '';
						}

						// Get agent and user changes
						const agentContent =
							conflict.agentChanges.length > 0 ? conflict.agentChanges[0].content : originalContent;
						const userContent =
							conflict.userChanges.length > 0 ? conflict.userChanges[0].content : originalContent;

						// Create a merged content with conflict markers
						const mergedContent = `<<<<<<< AGENT CHANGES
${agentContent}
=======
${userContent}
>>>>>>> USER CHANGES`;

						// Create a temporary file with the merged content
						const tempFilePath = `${conflict.filePath}.merge`;
						await diffService.applyFileChange({
							path: tempFilePath,
							content: mergedContent,
							type: 'create',
						});

						// Open the file in the editor
						const uri = vscode.Uri.file(tempFilePath);
						await vscode.window.showTextDocument(uri);

						// Show a message with instructions
						vscode.window
							.showInformationMessage(
								'Resolve the conflict by editing the file, then save it and use the "Complete Conflict Merge" command',
								'Complete Merge',
							)
							.then(async (selection) => {
								if (selection === 'Complete Merge') {
									// Get the content of the temporary file
									const resolvedContent = await diffService.getFileContent(tempFilePath);

									// Resolve the conflict with the merged content
									await vscode.commands.executeCommand(COMMANDS.RESOLVE_CONFLICT, {
										conflictId,
										resolvedContent,
									});

									// Delete the temporary file
									await diffService.deleteFile(tempFilePath);
								}
							});

						return {
							success: true,
							tempFilePath,
						};
					} catch (error) {
						console.error('Error merging conflict changes:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'MERGE_CONFLICT_CHANGES',
				'Merge changes for a conflict',
			),
		),
	];

	// Add commands to context subscriptions
	context.subscriptions.push(...commands);
}

================
File: commands/historyCommands.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import { StorageService } from '../services/storageService';
import { DiffService } from '../services/diffService';
import { FileChange } from '../models/types';
import { errorWrapper } from '../errorHandling';
import { COMMANDS, API_ENDPOINTS } from '../config';

/**
 * Register history management commands
 * @param context Extension context
 */
export function registerHistoryCommands(context: vscode.ExtensionContext): void {
	// Initialize services
	const storageService = StorageService.getInstance(context);
	const diffService = DiffService.getInstance();

	// Register commands
	const commands = [
		vscode.commands.registerCommand(
			COMMANDS.RECORD_HISTORY_ENTRY,
			errorWrapper(
				async (description: string, changes: any[]): Promise<any> => {
					console.log('Recording history entry:', description);

					try {
						// Create a history entry
						const historyEntry = {
							id: `history-${Date.now()}`,
							timestamp: new Date().toISOString(),
							description,
							changes: changes || [],
						};

						// Save the history entry
						await storageService.saveHistoryEntry(historyEntry);

						return {
							historyEntry,
							success: true,
						};
					} catch (error) {
						console.error('Error recording history entry:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'RECORD_HISTORY_ENTRY',
				'Record a history entry with changes',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.GET_HISTORY,
			errorWrapper(
				async (limit?: number): Promise<any[]> => {
					// Get history entries from storage
					const historyEntries = await storageService.getHistoryEntries();

					// If limit is provided, return only the most recent entries
					if (limit && limit > 0) {
						return historyEntries.slice(0, limit);
					}

					return historyEntries;
				},
				'GET_HISTORY',
				'Get history entries',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.CLEAR_HISTORY,
			errorWrapper(
				async (): Promise<boolean> => {
					console.log('Clearing history');

					// Clear all history entries
					await storageService.clearHistory();

					// Show a success message
					vscode.window.showInformationMessage('History cleared');

					return true;
				},
				'CLEAR_HISTORY',
				'Clear all history entries',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.VIEW_HISTORY_DIFF,
			errorWrapper(
				async (historyEntryId: string): Promise<void> => {
					console.log(`Viewing diff for history entry: ${historyEntryId}`);

					try {
						// Get the history entry
						const historyEntries = await storageService.getHistoryEntries();
						const historyEntry = historyEntries.find((h: any) => h.id === historyEntryId);

						if (!historyEntry) {
							throw new Error(`History entry ${historyEntryId} not found`);
						}

						// If there are no changes, show a message
						if (!historyEntry.changes || historyEntry.changes.length === 0) {
							vscode.window.showInformationMessage('This history entry has no changes');
							return;
						}

						// Show a quick pick to select a file
						interface FileItem {
							label: string;
							description: string;
							change: FileChange;
						}

						const fileItems: FileItem[] = historyEntry.changes.map((change: any) => ({
							label: change.path,
							description: `${change.type} file`,
							change,
						}));

						const selectedItem = await vscode.window.showQuickPick<FileItem>(fileItems, {
							placeHolder: 'Select a file to view diff',
						});

						if (!selectedItem) {
							return;
						}

						// Use the selected item directly
						const change = selectedItem.change;

						// For create or modify, show the diff
						if (change.type === 'create' || change.type === 'modify') {
							let originalContent = '';

							// For modify, get the original content from the change
							if (change.type === 'modify' && change.originalContent) {
								originalContent = change.originalContent;
							}

							// Show the diff
							await diffService.showDiff(
								originalContent,
								change.content,
								`Diff for ${change.path} (${change.type})`,
							);
						} else if (change.type === 'delete' && change.originalContent) {
							// For delete, show the original content that was deleted
							await diffService.showDiff(change.originalContent, '', `Diff for ${change.path} (delete)`);
						}
					} catch (error) {
						console.error(`Error viewing history diff: ${error}`);
						vscode.window.showErrorMessage(`Failed to view history diff: ${error}`);
					}
				},
				'VIEW_HISTORY_DIFF',
				'View diff for a history entry',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.REVERT_HISTORY_ENTRY,
			errorWrapper(
				async (historyEntryId: string): Promise<any> => {
					console.log(`Reverting history entry: ${historyEntryId}`);

					try {
						// Get the history entry
						const historyEntries = await storageService.getHistoryEntries();
						const historyEntry = historyEntries.find((h: any) => h.id === historyEntryId);

						if (!historyEntry) {
							throw new Error(`History entry ${historyEntryId} not found`);
						}

						// If there are no changes, show a message
						if (!historyEntry.changes || historyEntry.changes.length === 0) {
							vscode.window.showInformationMessage('This history entry has no changes to revert');
							return {
								success: false,
								message: 'No changes to revert',
							};
						}

						// Revert each change in reverse order
						const results = [];
						const reversedChanges = [...historyEntry.changes].reverse();

						for (const change of reversedChanges) {
							try {
								if (change.type === 'create') {
									// Revert a create by deleting the file
									await diffService.deleteFile(change.path);

									results.push({
										path: change.path,
										success: true,
									});
								} else if (change.type === 'modify' && change.originalContent) {
									// Revert a modify by restoring the original content
									await diffService.applyFileChange({
										path: change.path,
										content: change.originalContent,
										type: 'modify',
									});

									results.push({
										path: change.path,
										success: true,
									});
								} else if (change.type === 'delete' && change.originalContent) {
									// Revert a delete by recreating the file
									await diffService.applyFileChange({
										path: change.path,
										content: change.originalContent,
										type: 'create',
									});

									results.push({
										path: change.path,
										success: true,
									});
								} else {
									results.push({
										path: change.path,
										success: false,
										error: 'Missing original content for revert',
									});
								}
							} catch (error) {
								console.error(`Error reverting change to ${change.path}:`, error);
								results.push({
									path: change.path,
									success: false,
									error: error instanceof Error ? error.message : String(error),
								});
							}
						}

						// Show a success message
						const successCount = results.filter((r) => r.success).length;
						const failCount = results.length - successCount;

						if (failCount === 0) {
							vscode.window.showInformationMessage(
								`History entry reverted successfully (${successCount} files)`,
							);
						} else {
							vscode.window.showWarningMessage(
								`History entry reverted with issues: ${successCount} succeeded, ${failCount} failed`,
							);
						}

						// Record a new history entry for the revert
						await vscode.commands.executeCommand(
							COMMANDS.RECORD_HISTORY_ENTRY,
							`Reverted: ${historyEntry.description}`,
							results.map((r) => ({
								path: r.path,
								type: 'revert',
								success: r.success,
								error: r.error,
							})),
						);

						return {
							results,
							success: failCount === 0,
						};
					} catch (error) {
						console.error('Error reverting history entry:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'REVERT_HISTORY_ENTRY',
				'Revert changes from a history entry',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.SHOW_HISTORY_VIEW,
			errorWrapper(
				async (): Promise<void> => {
					console.log('Showing history view');

					try {
						// Get history entries
						const historyEntriesResult = await vscode.commands.executeCommand(COMMANDS.GET_HISTORY);
						const historyEntries = Array.isArray(historyEntriesResult) ? historyEntriesResult : [];

						if (!historyEntries || historyEntries.length === 0) {
							vscode.window.showInformationMessage('No history entries found');
							return;
						}

						// Create a webview panel
						const panel = vscode.window.createWebviewPanel(
							'historyView',
							'History',
							vscode.ViewColumn.One,
							{
								enableScripts: true,
							},
						);

						// Generate HTML for the webview
						panel.webview.html = generateHistoryViewHtml(historyEntries);

						// Handle messages from the webview
						panel.webview.onDidReceiveMessage(async (message) => {
							if (message.command === 'viewDiff') {
								await vscode.commands.executeCommand(
									COMMANDS.VIEW_HISTORY_DIFF,
									message.historyEntryId,
								);
							} else if (message.command === 'revertEntry') {
								await vscode.commands.executeCommand(
									COMMANDS.REVERT_HISTORY_ENTRY,
									message.historyEntryId,
								);

								// Refresh the webview
								const updatedHistoryEntriesResult = await vscode.commands.executeCommand(
									COMMANDS.GET_HISTORY,
								);
								const updatedHistoryEntries = Array.isArray(updatedHistoryEntriesResult)
									? updatedHistoryEntriesResult
									: [];
								panel.webview.html = generateHistoryViewHtml(updatedHistoryEntries);
							}
						});
					} catch (error) {
						console.error('Error showing history view:', error);
						vscode.window.showErrorMessage(`Failed to show history view: ${error}`);
					}
				},
				'SHOW_HISTORY_VIEW',
				'Show history view',
			),
		),
	];

	// Add commands to context subscriptions
	context.subscriptions.push(...commands);
}

/**
 * Generate HTML for the history view
 * @param historyEntries History entries to display
 * @returns HTML string
 */
function generateHistoryViewHtml(historyEntries: any[]): string {
	const entriesHtml = historyEntries
		.map((entry) => {
			const date = new Date(entry.timestamp).toLocaleString();
			const changesCount = entry.changes ? entry.changes.length : 0;

			return `
            <div class="history-entry">
                <div class="entry-header">
                    <span class="entry-date">${date}</span>
                    <span class="entry-description">${entry.description}</span>
                    <span class="entry-changes">${changesCount} changes</span>
                </div>
                <div class="entry-actions">
                    <button class="view-diff-btn" data-id="${entry.id}">View Diff</button>
                    <button class="revert-btn" data-id="${entry.id}">Revert</button>
                </div>
            </div>
        `;
		})
		.join('');

	return `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>History</title>
            <style>
                body {
                    font-family: var(--vscode-font-family);
                    padding: 10px;
                    color: var(--vscode-foreground);
                }
                .history-entry {
                    margin-bottom: 10px;
                    padding: 10px;
                    border: 1px solid var(--vscode-panel-border);
                    border-radius: 3px;
                }
                .entry-header {
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 5px;
                }
                .entry-date {
                    color: var(--vscode-descriptionForeground);
                    font-size: 0.9em;
                }
                .entry-description {
                    font-weight: bold;
                }
                .entry-changes {
                    color: var(--vscode-descriptionForeground);
                    font-size: 0.9em;
                }
                .entry-actions {
                    display: flex;
                    gap: 5px;
                }
                button {
                    background-color: var(--vscode-button-background);
                    color: var(--vscode-button-foreground);
                    border: none;
                    padding: 5px 10px;
                    border-radius: 3px;
                    cursor: pointer;
                }
                button:hover {
                    background-color: var(--vscode-button-hoverBackground);
                }
                .empty-message {
                    text-align: center;
                    margin-top: 20px;
                    color: var(--vscode-descriptionForeground);
                }
            </style>
        </head>
        <body>
            <h1>History</h1>
            ${entriesHtml || '<div class="empty-message">No history entries found</div>'}
            
            <script>
                const vscode = acquireVsCodeApi();
                
                // Add event listeners to buttons
                document.querySelectorAll('.view-diff-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        vscode.postMessage({
                            command: 'viewDiff',
                            historyEntryId: btn.dataset.id
                        });
                    });
                });
                
                document.querySelectorAll('.revert-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (confirm('Are you sure you want to revert these changes?')) {
                            vscode.postMessage({
                                command: 'revertEntry',
                                historyEntryId: btn.dataset.id
                            });
                        }
                    });
                });
            </script>
        </body>
        </html>
    `;
}

================
File: commands/implementationCommands.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import { StorageService } from '../services/storageService';
import { DiffService } from '../services/diffService';
import { CreateImplementationPayload, ApplyImplementationPayload } from '../models/types';
import { errorWrapper } from '../errorHandling';
import { COMMANDS, API_ENDPOINTS } from '../config';

/**
 * Register implementation management commands
 * @param context Extension context
 */
export function registerImplementationCommands(context: vscode.ExtensionContext): void {
	// Initialize services
	const storageService = StorageService.getInstance(context);
	const diffService = DiffService.getInstance();

	// Register commands
	const commands = [
		vscode.commands.registerCommand(
			COMMANDS.CREATE_IMPLEMENTATION,
			errorWrapper(
				async (payload: CreateImplementationPayload): Promise<any> => {
					console.log('Creating implementation:', payload.title);

					try {
						// Create an implementation
						const implementation = {
							id: `implementation-${Date.now()}`,
							timestamp: new Date().toISOString(),
							title: payload.title,
							description: payload.description,
							files: payload.files || [],
							status: 'pending' as const,
							author: payload.author || 'User',
							tags: payload.tags || [],
						};

						// Save the implementation
						await storageService.saveImplementation(implementation);

						return {
							implementation,
							success: true,
						};
					} catch (error) {
						console.error('Error creating implementation:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'CREATE_IMPLEMENTATION',
				'Create an implementation for a feature or bug fix',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.GET_IMPLEMENTATIONS,
			errorWrapper(
				async (status?: string): Promise<any[]> => {
					// Get all implementations from storage
					const implementations = await storageService.getImplementations();

					// If status is provided, filter implementations by status
					if (status) {
						return implementations.filter((i) => i.status === status);
					}

					return implementations;
				},
				'GET_IMPLEMENTATIONS',
				'Get all implementations or implementations with a specific status',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.DELETE_IMPLEMENTATION,
			errorWrapper(
				async (implementationId: string): Promise<boolean> => {
					console.log(`Deleting implementation: ${implementationId}`);

					// Delete the implementation from storage
					await storageService.deleteImplementation(implementationId);

					return true;
				},
				'DELETE_IMPLEMENTATION',
				'Delete an implementation',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.APPLY_IMPLEMENTATION,
			errorWrapper(
				async (payload: ApplyImplementationPayload): Promise<any> => {
					console.log(`Applying implementation: ${payload.implementationId}`);

					try {
						// Get the implementation
						const implementations = await storageService.getImplementations();
						const implementation = implementations.find((i) => i.id === payload.implementationId);

						if (!implementation) {
							throw new Error(`Implementation ${payload.implementationId} not found`);
						}

						// Apply each file change
						const results = [];

						for (const file of implementation.files) {
							try {
								if (file.type === 'create' || file.type === 'modify') {
									// Apply the file change
									await diffService.applyFileChange({
										path: file.path,
										content: file.content,
										type: file.type,
									});

									results.push({
										path: file.path,
										success: true,
									});
								} else if (file.type === 'delete') {
									// Delete the file
									await diffService.deleteFile(file.path);

									results.push({
										path: file.path,
										success: true,
									});
								}
							} catch (error) {
								console.error(`Error applying change to ${file.path}:`, error);
								results.push({
									path: file.path,
									success: false,
									error: error instanceof Error ? error.message : String(error),
								});
							}
						}

						// Update the implementation status
						implementation.status = 'applied';
						await storageService.saveImplementation(implementation);

						// Show a success message
						const successCount = results.filter((r) => r.success).length;
						const failCount = results.length - successCount;

						if (failCount === 0) {
							vscode.window.showInformationMessage(
								`Implementation applied successfully (${successCount} files)`,
							);
						} else {
							vscode.window.showWarningMessage(
								`Implementation applied with issues: ${successCount} succeeded, ${failCount} failed`,
							);
						}

						return {
							results,
							success: failCount === 0,
						};
					} catch (error) {
						console.error('Error applying implementation:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'APPLY_IMPLEMENTATION',
				'Apply an implementation to the workspace',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.VIEW_IMPLEMENTATION_DIFF,
			errorWrapper(
				async (implementationId: string): Promise<void> => {
					console.log(`Viewing diff for implementation: ${implementationId}`);

					try {
						// Get the implementation
						const implementations = await storageService.getImplementations();
						const implementation = implementations.find((i) => i.id === implementationId);

						if (!implementation) {
							throw new Error(`Implementation ${implementationId} not found`);
						}

						// If there are no files, show a message
						if (!implementation.files || implementation.files.length === 0) {
							vscode.window.showInformationMessage('This implementation has no file changes');
							return;
						}

						// Show a quick pick to select a file
						const fileItems = implementation.files.map((file) => ({
							label: file.path,
							description: `${file.type} file`,
							file,
						}));

						const selectedItem = await vscode.window.showQuickPick(fileItems, {
							placeHolder: 'Select a file to view diff',
						});

						if (!selectedItem) {
							return;
						}

						const file = selectedItem.file;

						// For create or modify, show the diff
						if (file.type === 'create' || file.type === 'modify') {
							let originalContent = '';

							// For modify, get the current file content
							if (file.type === 'modify') {
								try {
									const fileContent = await diffService.getFileContent(file.path);
									originalContent = fileContent || '';
								} catch (error) {
									console.error(`Error getting file content for ${file.path}:`, error);
									originalContent = '';
								}
							}

							// Show the diff
							await diffService.showDiff(
								originalContent,
								file.content,
								`Diff for ${file.path} (${file.type})`,
							);
						} else if (file.type === 'delete') {
							// For delete, show the file content that will be deleted
							try {
								const fileContent = await diffService.getFileContent(file.path);
								const content = fileContent || '';
								await diffService.showDiff(content, '', `Diff for ${file.path} (delete)`);
							} catch (error) {
								console.error(`Error getting file content for ${file.path}:`, error);
								vscode.window.showErrorMessage(`Failed to get content for ${file.path}`);
							}
						}
					} catch (error) {
						console.error(`Error viewing implementation diff: ${error}`);
						vscode.window.showErrorMessage(`Failed to view implementation diff: ${error}`);
					}
				},
				'VIEW_IMPLEMENTATION_DIFF',
				'View diff for an implementation',
			),
		),

		vscode.commands.registerCommand(
			COMMANDS.UPDATE_IMPLEMENTATION_STATUS,
			errorWrapper(
				async (implementationId: string, status: string): Promise<boolean> => {
					console.log(`Updating implementation ${implementationId} status to: ${status}`);

					try {
						// Get the implementation
						const implementations = await storageService.getImplementations();
						const implementationIndex = implementations.findIndex((i) => i.id === implementationId);

						if (implementationIndex === -1) {
							throw new Error(`Implementation ${implementationId} not found`);
						}

						// Update the status
						implementations[implementationIndex].status = status as 'pending' | 'rejected' | 'applied';

						// Save the implementation
						await storageService.saveImplementation(implementations[implementationIndex]);

						// Show a success message
						vscode.window.showInformationMessage(
							`Implementation ${implementationId} status updated to ${status}`,
						);

						return true;
					} catch (error) {
						console.error(`Error updating implementation status: ${error}`);
						vscode.window.showErrorMessage(`Failed to update implementation status: ${error}`);
						return false;
					}
				},
				'UPDATE_IMPLEMENTATION_STATUS',
				'Update the status of an implementation',
			),
		),
	];

	// Add commands to context subscriptions
	context.subscriptions.push(...commands);
}

================
File: common/log/logging.ts
================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

import * as util from 'util';
import { Disposable, LogOutputChannel } from 'vscode';

type Arguments = unknown[];
class OutputChannelLogger {
    constructor(private readonly channel: LogOutputChannel) {}

    public traceLog(...data: Arguments): void {
        this.channel.appendLine(util.format(...data));
    }

    public traceError(...data: Arguments): void {
        this.channel.error(util.format(...data));
    }

    public traceWarn(...data: Arguments): void {
        this.channel.warn(util.format(...data));
    }

    public traceInfo(...data: Arguments): void {
        this.channel.info(util.format(...data));
    }

    public traceVerbose(...data: Arguments): void {
        this.channel.debug(util.format(...data));
    }
}

let channel: OutputChannelLogger | undefined;
export function registerLogger(logChannel: LogOutputChannel): Disposable {
    channel = new OutputChannelLogger(logChannel);
    return {
        dispose: () => {
            channel = undefined;
        },
    };
}

export function traceLog(...args: Arguments): void {
    channel?.traceLog(...args);
}

export function traceError(...args: Arguments): void {
    channel?.traceError(...args);
}

export function traceWarn(...args: Arguments): void {
    channel?.traceWarn(...args);
}

export function traceInfo(...args: Arguments): void {
    channel?.traceInfo(...args);
}

export function traceVerbose(...args: Arguments): void {
    channel?.traceVerbose(...args);
}

================
File: common/constants.ts
================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

import * as path from 'path';

const folderName = path.basename(__dirname);
export const EXTENSION_ROOT_DIR =
    folderName === 'common' ? path.dirname(path.dirname(__dirname)) : path.dirname(__dirname);
export const BUNDLED_PYTHON_SCRIPTS_DIR = path.join(EXTENSION_ROOT_DIR, 'bundled');
export const SERVER_SCRIPT_PATH = path.join(BUNDLED_PYTHON_SCRIPTS_DIR, 'tool', `lsp_server.py`);
export const DEBUG_SERVER_SCRIPT_PATH = path.join(BUNDLED_PYTHON_SCRIPTS_DIR, 'tool', `_debug_server.py`);

================
File: common/python.ts
================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

/* eslint-disable @typescript-eslint/naming-convention */
import { commands, Disposable, Event, EventEmitter, Uri, WorkspaceFolder } from 'vscode';
import { traceError, traceLog, traceVerbose } from './log/logging';
import {
	PythonExtension,
	ResolvedEnvironment,
	Bitness,
	VersionInfo,
	ResolvedVersionInfo,
	PythonReleaseLevel,
} from '@vscode/python-extension';
import * as fs from 'fs';
import * as path from 'path';
import { workspace } from 'vscode';

// Define a proper interface for ResolvedInterpreter to match what we're returning
export interface ResolvedInterpreter {
	type: string;
	name: string;
	folderUri: Uri;
	workspaceFolder: WorkspaceFolder | undefined;
	path: string;
	version: ResolvedVersionInfo;
	sysPrefix: string;
	architecture: number;
	sysVersion: string;
	executable: {
		filename: string;
		sysPrefix: string;
		ctime: number;
		mtime: number;
		bitness: Bitness;
	};
}

export interface IInterpreterDetails {
	path?: string[];
	resource?: Uri;
	version?: {
		major: number;
		minor: number;
		micro: number;
		raw: string;
	};
	sysPrefix?: string;
	architecture?: number;
}

const onDidChangePythonInterpreterEvent = new EventEmitter<IInterpreterDetails>();
export const onDidChangePythonInterpreter: Event<IInterpreterDetails> = onDidChangePythonInterpreterEvent.event;

let _api: PythonExtension | undefined;
async function getPythonExtensionAPI(): Promise<PythonExtension | undefined> {
	if (_api) {
		return _api;
	}
	try {
		_api = await PythonExtension.api();
		return _api;
	} catch (error) {
		traceVerbose('Python extension API not available:', error);
		return undefined;
	}
}

export async function initializePython(disposables: Disposable[]): Promise<void> {
	try {
		const api = await getPythonExtensionAPI();

		if (api) {
			traceLog('Python extension API available, setting up event listeners');
			disposables.push(
				api.environments.onDidChangeActiveEnvironmentPath((e) => {
					onDidChangePythonInterpreterEvent.fire({ path: [e.path], resource: e.resource?.uri });
				}),
			);

			traceLog('Waiting for interpreter from python extension.');
			onDidChangePythonInterpreterEvent.fire(await getInterpreterDetails());
		} else {
			traceLog('Python extension API not available, will use bundled Python if available');
			// Fire an empty event to signal that we should fall back to bundled Python
			onDidChangePythonInterpreterEvent.fire({ path: undefined, resource: undefined });
		}
	} catch (error) {
		traceError('Error initializing python: ', error);
		// Fire an empty event to signal that we should fall back to bundled Python
		onDidChangePythonInterpreterEvent.fire({ path: undefined, resource: undefined });
	}
}

export async function resolveInterpreter(pythonPath: string): Promise<ResolvedInterpreter | undefined> {
	try {
		if (!fs.existsSync(pythonPath)) {
			traceError(`Python interpreter not found at ${pythonPath}`);
			return undefined;
		}

		const uri = Uri.file(pythonPath);
		const workspaceFolder = workspace.getWorkspaceFolder(uri);

		// Create a basic version object with default values
		const version: ResolvedVersionInfo = {
			major: 3,
			minor: 8,
			micro: 0,
			release: {
				level: 'final' as PythonReleaseLevel,
				serial: 0,
			},
		};

		// Get the directory containing the Python executable
		const sysPrefix = path.dirname(path.dirname(pythonPath));

		return {
			type: 'Unknown',
			name: path.basename(pythonPath),
			folderUri: workspaceFolder ? workspaceFolder.uri : Uri.file(path.dirname(pythonPath)),
			workspaceFolder: workspaceFolder,
			path: pythonPath,
			version: version,
			sysPrefix: sysPrefix,
			architecture: 64, // Assume 64-bit
			sysVersion: '3.8.0', // Store version string separately from ResolvedVersionInfo
			executable: {
				filename: pythonPath,
				sysPrefix: sysPrefix,
				ctime: 0,
				mtime: 0,
				bitness: 64 as unknown as Bitness,
			},
		};
	} catch (ex) {
		traceError(`Failed to resolve interpreter: ${ex}`);
		return undefined;
	}
}

export async function getInterpreterDetails(resource?: Uri | string): Promise<IInterpreterDetails> {
	// If resource is a string, assume it's a path to a Python interpreter
	if (typeof resource === 'string') {
		try {
			if (!fs.existsSync(resource)) {
				return { path: undefined };
			}

			// Create a basic version object with default values
			const version = {
				major: 3,
				minor: 8,
				micro: 0,
				raw: '3.8.0',
			};

			// Get the directory containing the Python executable
			const sysPrefix = path.dirname(path.dirname(resource));

			return {
				path: [resource],
				version: version,
				sysPrefix: sysPrefix,
				architecture: 64, // Assume 64-bit
			};
		} catch (error) {
			traceError(`Error getting interpreter details for ${resource}: ${error}`);
			return { path: undefined };
		}
	}

	const api = await getPythonExtensionAPI();
	if (!api) {
		traceLog('Python extension not available, returning empty interpreter details');
		return { path: undefined, resource };
	}

	try {
		const environment = await api?.environments.resolveEnvironment(
			api?.environments.getActiveEnvironmentPath(resource),
		);
		if (environment?.executable.uri && checkVersion(environment)) {
			return {
				path: [environment?.executable.uri.fsPath],
				resource,
				version: {
					major: environment.version?.major || 3,
					minor: environment.version?.minor || 8,
					micro: environment.version?.micro || 0,
					raw: environment.version?.sysVersion || '3.8.0',
				},
				sysPrefix: environment.executable.sysPrefix,
				architecture: Number(environment.executable.bitness) === 64 ? 64 : 32,
			};
		}
	} catch (error) {
		traceError('Error getting interpreter details from Python extension:', error);
	}
	return { path: undefined, resource };
}

export async function getDebuggerPath(): Promise<string | undefined> {
	const api = await getPythonExtensionAPI();
	if (!api) {
		return undefined;
	}
	return api?.debug.getDebuggerPackagePath();
}

export async function runPythonExtensionCommand(command: string, ...rest: any[]) {
	const api = await getPythonExtensionAPI();
	if (!api) {
		traceError(`Cannot run Python extension command ${command}: Python extension not available`);
		return undefined;
	}
	return await commands.executeCommand(command, ...rest);
}

export function checkVersion(resolved: ResolvedEnvironment | undefined): boolean {
	if (!resolved) {
		return false;
	}
	const version = resolved?.version;
	if (version && version.major === 3 && version.minor >= 8) {
		return true;
	}
	traceError(`Python version ${version?.major}.${version?.minor} is not supported.`);
	traceError(`Selected python path: ${resolved?.executable.uri?.fsPath}`);
	traceError('Supported versions are 3.8 and above.');
	return false;
}

================
File: common/server.ts
================
/* eslint-disable header/header */

import * as fsapi from 'fs-extra';
import * as path from 'path';
import { Disposable, env, LogOutputChannel } from 'vscode';
import { State } from 'vscode-languageclient';
import {
	LanguageClient,
	LanguageClientOptions,
	RevealOutputChannelOn,
	ServerOptions,
} from 'vscode-languageclient/node';
import { DEBUG_SERVER_SCRIPT_PATH, SERVER_SCRIPT_PATH } from './constants';
import { traceError, traceInfo, traceVerbose } from './log/logging';
import { getDebuggerPath } from './python';
import { getExtensionSettings, getGlobalSettings, getWorkspaceSettings, ISettings } from './settings';
import { getLSClientTraceLevel, getProjectRoot } from './utilities';
import { isVirtualWorkspace } from './vscodeapi';

export type IInitOptions = { settings: ISettings[]; globalSettings: ISettings };

async function createServer(
	settings: ISettings,
	serverId: string,
	serverName: string,
	outputChannel: LogOutputChannel,
	initializationOptions: IInitOptions,
): Promise<LanguageClient> {
	const command = settings.interpreter[0];
	const cwd = settings.cwd;

	// Set up environment variables
	const extensionRoot = path.dirname(path.dirname(__dirname));
	const bundledLibsPath = path.join(extensionRoot, 'bundled', 'libs');
	const bundledToolPath = path.join(extensionRoot, 'bundled', 'tool');
	const newEnv = { ...process.env };
	newEnv.PYTHONPATH = [bundledLibsPath, bundledToolPath, process.env.PYTHONPATH].filter(Boolean).join(path.delimiter);

	// Set debugger path needed for debugging python code.
	let debuggerPath;
	try {
		debuggerPath = await getDebuggerPath();
	} catch (error) {
		traceVerbose(`Error getting debugger path: ${error}`);
		debuggerPath = undefined;
	}

	const isDebugScript = await fsapi.pathExists(DEBUG_SERVER_SCRIPT_PATH);
	if (newEnv.USE_DEBUGPY && debuggerPath) {
		newEnv.DEBUGPY_PATH = debuggerPath;
	} else {
		newEnv.USE_DEBUGPY = 'False';
	}

	// Set import strategy
	newEnv.LS_IMPORT_STRATEGY = settings.importStrategy;

	// Set notification type
	newEnv.LS_SHOW_NOTIFICATION = settings.showNotifications;

	const args =
		newEnv.USE_DEBUGPY === 'False' || !isDebugScript
			? settings.interpreter.slice(1).concat([SERVER_SCRIPT_PATH])
			: settings.interpreter.slice(1).concat([DEBUG_SERVER_SCRIPT_PATH]);
	traceInfo(`Server run command: ${[command, ...args].join(' ')}`);

	const serverOptions: ServerOptions = {
		command,
		args,
		options: { cwd, env: newEnv },
	};

	// Options to control the language client
	const clientOptions: LanguageClientOptions = {
		// Register the server for python documents
		documentSelector: isVirtualWorkspace()
			? [{ language: 'python' }]
			: [
					{ scheme: 'file', language: 'python' },
					{ scheme: 'untitled', language: 'python' },
					{ scheme: 'vscode-notebook', language: 'python' },
					{ scheme: 'vscode-notebook-cell', language: 'python' },
				],
		outputChannel: outputChannel,
		traceOutputChannel: outputChannel,
		revealOutputChannelOn: RevealOutputChannelOn.Never,
		initializationOptions,
	};

	return new LanguageClient(serverId, serverName, serverOptions, clientOptions);
}

let _disposables: Disposable[] = [];
let _isRestarting = false;
let _restartTimeoutId: NodeJS.Timeout | undefined;

export async function restartServer(
	serverId: string,
	serverName: string,
	outputChannel: LogOutputChannel,
	lsClient?: LanguageClient,
): Promise<LanguageClient | undefined> {
	// Debounce server restarts to prevent race conditions
	if (_isRestarting) {
		traceInfo(`Server: Restart already in progress, debouncing this request`);

		// Clear any existing timeout
		if (_restartTimeoutId) {
			clearTimeout(_restartTimeoutId);
		}

		// Return the current client, a new restart will be triggered after the current one completes
		return lsClient;
	}

	_isRestarting = true;

	try {
		if (lsClient) {
			traceInfo(`Server: Stop requested`);
			try {
				// Check if the client is in a state where it can be stopped
				if (lsClient.state === State.Running || lsClient.state === State.Starting) {
					await lsClient.stop();
				} else {
					traceInfo(`Server: Client is not running (state: ${State[lsClient.state]}), skipping stop`);
				}
			} catch (ex) {
				traceError(`Server: Error stopping client: ${ex}`);
				// Continue with creating a new client even if stopping the old one failed
			}
			_disposables.forEach((d) => d.dispose());
			_disposables = [];
		}
		const projectRoot = await getProjectRoot();
		const workspaceSetting = await getWorkspaceSettings(serverId, projectRoot, true);

		// Ensure we have a valid interpreter
		if (!workspaceSetting.interpreter || workspaceSetting.interpreter.length === 0) {
			traceError('No Python interpreter available. Server cannot be started.');
			return undefined;
		}

		try {
			const newLSClient = await createServer(workspaceSetting, serverId, serverName, outputChannel, {
				settings: await getExtensionSettings(serverId, true),
				globalSettings: await getGlobalSettings(serverId, false),
			});
			traceInfo(`Server: Start requested.`);
			_disposables.push(
				newLSClient.onDidChangeState((e) => {
					switch (e.newState) {
						case State.Stopped:
							traceVerbose(`Server State: Stopped`);
							break;
						case State.Starting:
							traceVerbose(`Server State: Starting`);
							break;
						case State.Running:
							traceVerbose(`Server State: Running`);
							break;
					}
				}),
			);
			try {
				// Add a timeout to prevent hanging if the server doesn't start
				const startPromise = newLSClient.start();
				const timeoutPromise = new Promise<void>((_, reject) => {
					const timeout = setTimeout(() => {
						clearTimeout(timeout);
						reject(new Error('Server start timed out after 30 seconds'));
					}, 30000);
				});

				await Promise.race([startPromise, timeoutPromise]).catch((ex) => {
					traceError(`Server: Start failed: ${ex}`);
					return undefined;
				});
			} catch (ex) {
				traceError(`Server: Start failed: ${ex}`);
				return undefined;
			}

			const level = getLSClientTraceLevel(outputChannel.logLevel, env.logLevel);
			await newLSClient.setTrace(level);
			return newLSClient;
		} catch (error) {
			traceError(`Error creating server: ${error}`);
			return undefined;
		}
	} finally {
		_isRestarting = false;
	}
}

================
File: common/settings.ts
================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

import { ConfigurationChangeEvent, ConfigurationScope, WorkspaceConfiguration, WorkspaceFolder } from 'vscode';
import { getInterpreterDetails } from './python';
import { getConfiguration, getWorkspaceFolders } from './vscodeapi';

export interface ISettings {
    cwd: string;
    workspace: string;
    args: string[];
    path: string[];
    interpreter: string[];
    importStrategy: string;
    showNotifications: string;
}

export function getExtensionSettings(namespace: string, includeInterpreter?: boolean): Promise<ISettings[]> {
    return Promise.all(getWorkspaceFolders().map((w) => getWorkspaceSettings(namespace, w, includeInterpreter)));
}

function resolveVariables(value: string[], workspace?: WorkspaceFolder): string[] {
    const substitutions = new Map<string, string>();
    const home = process.env.HOME || process.env.USERPROFILE;
    if (home) {
        substitutions.set('${userHome}', home);
    }
    if (workspace) {
        substitutions.set('${workspaceFolder}', workspace.uri.fsPath);
    }
    substitutions.set('${cwd}', process.cwd());
    getWorkspaceFolders().forEach((w) => {
        substitutions.set('${workspaceFolder:' + w.name + '}', w.uri.fsPath);
    });

    return value.map((s) => {
        for (const [key, value] of substitutions) {
            s = s.replace(key, value);
        }
        return s;
    });
}

export function getInterpreterFromSetting(namespace: string, scope?: ConfigurationScope) {
    const config = getConfiguration(namespace, scope);
    return config.get<string[]>('interpreter');
}

export async function getWorkspaceSettings(
    namespace: string,
    workspace: WorkspaceFolder,
    includeInterpreter?: boolean,
): Promise<ISettings> {
    const config = getConfiguration(namespace, workspace.uri);

    let interpreter: string[] = [];
    if (includeInterpreter) {
        interpreter = getInterpreterFromSetting(namespace, workspace) ?? [];
        if (interpreter.length === 0) {
            interpreter = (await getInterpreterDetails(workspace.uri)).path ?? [];
        }
    }

    const workspaceSetting = {
        cwd: workspace.uri.fsPath,
        workspace: workspace.uri.toString(),
        args: resolveVariables(config.get<string[]>(`args`) ?? [], workspace),
        path: resolveVariables(config.get<string[]>(`path`) ?? [], workspace),
        interpreter: resolveVariables(interpreter, workspace),
        importStrategy: config.get<string>(`importStrategy`) ?? 'useBundled',
        showNotifications: config.get<string>(`showNotifications`) ?? 'off',
    };
    return workspaceSetting;
}

function getGlobalValue<T>(config: WorkspaceConfiguration, key: string, defaultValue: T): T {
    const inspect = config.inspect<T>(key);
    return inspect?.globalValue ?? inspect?.defaultValue ?? defaultValue;
}

export async function getGlobalSettings(namespace: string, includeInterpreter?: boolean): Promise<ISettings> {
    const config = getConfiguration(namespace);

    let interpreter: string[] = [];
    if (includeInterpreter) {
        interpreter = getGlobalValue<string[]>(config, 'interpreter', []);
        if (interpreter === undefined || interpreter.length === 0) {
            interpreter = (await getInterpreterDetails()).path ?? [];
        }
    }

    const setting = {
        cwd: process.cwd(),
        workspace: process.cwd(),
        args: getGlobalValue<string[]>(config, 'args', []),
        path: getGlobalValue<string[]>(config, 'path', []),
        interpreter: interpreter,
        importStrategy: getGlobalValue<string>(config, 'importStrategy', 'useBundled'),
        showNotifications: getGlobalValue<string>(config, 'showNotifications', 'off'),
    };
    return setting;
}

export function checkIfConfigurationChanged(e: ConfigurationChangeEvent, namespace: string): boolean {
    const settings = [
        `${namespace}.args`,
        `${namespace}.path`,
        `${namespace}.interpreter`,
        `${namespace}.importStrategy`,
        `${namespace}.showNotifications`,
    ];
    const changed = settings.map((s) => e.affectsConfiguration(s));
    return changed.includes(true);
}

================
File: common/setup.ts
================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

import * as path from 'path';
import * as fs from 'fs-extra';
import { EXTENSION_ROOT_DIR } from './constants';

export interface IServerInfo {
    name: string;
    module: string;
}

export function loadServerDefaults(): IServerInfo {
    const packageJson = path.join(EXTENSION_ROOT_DIR, 'package.json');
    const content = fs.readFileSync(packageJson).toString();
    const config = JSON.parse(content);
    return config.serverInfo as IServerInfo;
}

================
File: common/utilities.ts
================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

import * as fs from 'fs-extra';
import * as path from 'path';
import { LogLevel, Uri, WorkspaceFolder } from 'vscode';
import { Trace } from 'vscode-jsonrpc/node';
import { getWorkspaceFolders } from './vscodeapi';

function logLevelToTrace(logLevel: LogLevel): Trace {
    switch (logLevel) {
        case LogLevel.Error:
        case LogLevel.Warning:
        case LogLevel.Info:
            return Trace.Messages;

        case LogLevel.Debug:
        case LogLevel.Trace:
            return Trace.Verbose;

        case LogLevel.Off:
        default:
            return Trace.Off;
    }
}

export function getLSClientTraceLevel(channelLogLevel: LogLevel, globalLogLevel: LogLevel): Trace {
    if (channelLogLevel === LogLevel.Off) {
        return logLevelToTrace(globalLogLevel);
    }
    if (globalLogLevel === LogLevel.Off) {
        return logLevelToTrace(channelLogLevel);
    }
    const level = logLevelToTrace(channelLogLevel <= globalLogLevel ? channelLogLevel : globalLogLevel);
    return level;
}

export async function getProjectRoot(): Promise<WorkspaceFolder> {
    const workspaces: readonly WorkspaceFolder[] = getWorkspaceFolders();
    if (workspaces.length === 0) {
        return {
            uri: Uri.file(process.cwd()),
            name: path.basename(process.cwd()),
            index: 0,
        };
    } else if (workspaces.length === 1) {
        return workspaces[0];
    } else {
        let rootWorkspace = workspaces[0];
        let root = undefined;
        for (const w of workspaces) {
            if (await fs.pathExists(w.uri.fsPath)) {
                root = w.uri.fsPath;
                rootWorkspace = w;
                break;
            }
        }

        for (const w of workspaces) {
            if (root && root.length > w.uri.fsPath.length && (await fs.pathExists(w.uri.fsPath))) {
                root = w.uri.fsPath;
                rootWorkspace = w;
            }
        }
        return rootWorkspace;
    }
}

================
File: common/vscodeapi.ts
================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
import {
    commands,
    ConfigurationScope,
    Disposable,
    LogOutputChannel,
    Uri,
    window,
    workspace,
    WorkspaceConfiguration,
    WorkspaceFolder,
} from 'vscode';

export function createOutputChannel(name: string): LogOutputChannel {
    return window.createOutputChannel(name, { log: true });
}

export function getConfiguration(config: string, scope?: ConfigurationScope): WorkspaceConfiguration {
    return workspace.getConfiguration(config, scope);
}

export function registerCommand(command: string, callback: (...args: any[]) => any, thisArg?: any): Disposable {
    return commands.registerCommand(command, callback, thisArg);
}

export const { onDidChangeConfiguration } = workspace;

export function isVirtualWorkspace(): boolean {
    const isVirtual = workspace.workspaceFolders && workspace.workspaceFolders.every((f) => f.uri.scheme !== 'file');
    return !!isVirtual;
}

export function getWorkspaceFolders(): readonly WorkspaceFolder[] {
    return workspace.workspaceFolders ?? [];
}

export function getWorkspaceFolder(uri: Uri): WorkspaceFolder | undefined {
    return workspace.getWorkspaceFolder(uri);
}

================
File: models/errorHandling.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';

/**
 * Error severity levels
 */
export enum ErrorSeverity {
	INFO = 'info',
	WARNING = 'warning',
	ERROR = 'error',
	CRITICAL = 'critical',
}

/**
 * Extension error interface
 */
export interface ExtensionError {
	code: string;
	message: string;
	details?: any;
	severity: ErrorSeverity;
	timestamp: Date;
}

/**
 * Error listener function type
 */
export type ErrorListener = (error: ExtensionError) => void;

/**
 * Extension error handler class
 */
export class ExtensionErrorHandler {
	private static instance: ExtensionErrorHandler;
	private listeners: ErrorListener[] = [];
	private errorLog: ExtensionError[] = [];
	private outputChannel: vscode.OutputChannel | null = null;

	private constructor() {}

	/**
	 * Get the singleton instance of the error handler
	 */
	public static getInstance(): ExtensionErrorHandler {
		if (!ExtensionErrorHandler.instance) {
			ExtensionErrorHandler.instance = new ExtensionErrorHandler();
		}
		return ExtensionErrorHandler.instance;
	}

	/**
	 * Initialize the error handler with the extension context
	 * @param context Extension context
	 */
	public init(context: vscode.ExtensionContext): void {
		this.outputChannel = vscode.window.createOutputChannel('Tribe Error Log');
		context.subscriptions.push(this.outputChannel);
	}

	/**
	 * Add an error listener
	 * @param listener Error listener function
	 */
	public addErrorListener(listener: ErrorListener): void {
		this.listeners.push(listener);
	}

	/**
	 * Remove an error listener
	 * @param listener Error listener function to remove
	 */
	public removeErrorListener(listener: ErrorListener): void {
		this.listeners = this.listeners.filter((l) => l !== listener);
	}

	/**
	 * Handle an error
	 * @param error Extension error
	 */
	public handleError(error: ExtensionError): void {
		// Add to error log
		this.errorLog.push(error);

		// Log to output channel
		if (this.outputChannel) {
			this.outputChannel.appendLine(
				`[${error.timestamp.toISOString()}] [${error.severity}] [${error.code}] ${error.message}`,
			);
			if (error.details) {
				this.outputChannel.appendLine(`Details: ${JSON.stringify(error.details, null, 2)}`);
			}
		}

		// Notify listeners
		this.listeners.forEach((listener) => {
			try {
				listener(error);
			} catch (e) {
				console.error('Error in error listener:', e);
			}
		});

		// Show notification based on severity
		switch (error.severity) {
			case ErrorSeverity.INFO:
				vscode.window.showInformationMessage(`[${error.code}] ${error.message}`);
				break;
			case ErrorSeverity.WARNING:
				vscode.window.showWarningMessage(`[${error.code}] ${error.message}`);
				break;
			case ErrorSeverity.ERROR:
			case ErrorSeverity.CRITICAL:
				vscode.window.showErrorMessage(`[${error.code}] ${error.message}`);
				break;
		}
	}

	/**
	 * Get the error log
	 */
	public getErrorLog(): ExtensionError[] {
		return [...this.errorLog];
	}

	/**
	 * Clear the error log
	 */
	public clearErrorLog(): void {
		this.errorLog = [];
	}
}

/**
 * Create an extension error
 * @param code Error code
 * @param message Error message
 * @param severity Error severity
 * @param details Additional error details
 */
export function createError(
	code: string,
	message: string,
	severity: ErrorSeverity = ErrorSeverity.ERROR,
	details?: any,
): ExtensionError {
	return {
		code,
		message,
		details,
		severity,
		timestamp: new Date(),
	};
}

/**
 * Error wrapper for async functions
 * @param fn Function to wrap
 * @param code Error code prefix
 * @param description Function description
 */
export function errorWrapper<T extends (...args: any[]) => Promise<any>>(
	fn: T,
	code: string,
	description: string,
): (...args: Parameters<T>) => Promise<ReturnType<T>> {
	return async (...args: Parameters<T>): Promise<ReturnType<T>> => {
		try {
			return await fn(...args);
		} catch (error) {
			const errorHandler = ExtensionErrorHandler.getInstance();
			const extensionError = createError(
				`${code}_ERROR`,
				`Error in ${description}: ${error instanceof Error ? error.message : String(error)}`,
				ErrorSeverity.ERROR,
				{
					originalError: error,
					functionName: fn.name,
					arguments: args,
				},
			);
			errorHandler.handleError(extensionError);
			throw error;
		}
	};
}

================
File: models/types.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';

/**
 * Types for change management
 */
export interface FileChange {
	path: string;
	content: string;
	type: 'create' | 'modify' | 'delete';
	originalContent?: string;
	explanation?: string;
}

export interface ChangeGroup {
	id: string;
	timestamp: string;
	title: string;
	description: string;
	files: FileChange[];
	status: 'pending' | 'accepted' | 'rejected' | 'partial';
	tags?: string[];
}

export interface ApplyChangesPayload {
	files: {
		modify: { [path: string]: string };
		create: { [path: string]: string };
		delete: string[];
	};
}

/**
 * Types for checkpoint management
 */
export interface Checkpoint {
	id: string;
	timestamp: string;
	description: string;
	changes: {
		modified: number;
		created: number;
		deleted: number;
	};
	snapshotPath: string;
	changeGroups?: string[];
	subCheckpoints?: SubCheckpoint[];
}

export interface SubCheckpoint {
	id: string;
	timestamp: string;
	description: string;
	changes: FileChange[];
	parentCheckpointId?: string;
}

export interface CreateCheckpointPayload {
	description: string;
	changeGroups?: string[];
}

export interface CreateSubCheckpointPayload {
	parentCheckpointId: string;
	description: string;
	changes: FileChange[];
}

export interface RevertToSubCheckpointPayload {
	checkpointId: string;
	subCheckpointId: string;
}

export interface WorkspaceSnapshot {
	[filePath: string]: string;
}

/**
 * Types for annotation management
 */
export interface AnnotationReply {
	id: string;
	timestamp: string;
	content: string;
	author: string;
}

export interface Annotation {
	id: string;
	timestamp: string;
	filePath: string;
	lineNumber: number;
	content: string;
	author: string;
	replies: AnnotationReply[];
	resolved: boolean;
	tags?: string[];
}

export interface CreateAnnotationPayload {
	filePath: string;
	lineNumber: number;
	content: string;
	author?: string;
	tags?: string[];
}

export interface AddReplyPayload {
	parentId: string;
	content: string;
	author?: string;
}

/**
 * Types for implementation management
 */
export interface Implementation {
	id: string;
	timestamp: string;
	title: string;
	description: string;
	files: FileChange[];
	status: 'pending' | 'applied' | 'rejected';
	author: string;
	tags?: string[];
}

export interface CreateImplementationPayload {
	title: string;
	description: string;
	files?: FileChange[];
	author?: string;
	tags?: string[];
}

export interface ApplyImplementationPayload {
	implementationId: string;
}

/**
 * Types for conflict management
 */
export interface Conflict {
	id: string;
	timestamp: string;
	title: string;
	description: string;
	filePath: string;
	status: 'unresolved' | 'resolved';
	agentChanges: FileChange[];
	userChanges: FileChange[];
	resolvedContent: string | null;
	conflictingChanges?: Record<string, FileChange[]>;
	resolvedChanges?: FileChange[];
	resolutionStrategy?: 'auto' | 'manual';
	resolutionTimestamp?: string;
}

export interface CreateConflictPayload {
	title: string;
	description: string;
	filePath: string;
	agentChanges?: FileChange[];
	userChanges?: FileChange[];
}

export interface ResolveConflictPayload {
	conflictId: string;
	resolvedContent: string;
}

/**
 * Types for history management
 */
export interface HistoryEntry {
	id: string;
	timestamp: string;
	description: string;
	changes: FileChange[];
}

/**
 * Types for change group management
 */
export interface CreateChangeGroupPayload {
	title: string;
	description: string;
	files?: FileChange[];
	filesToModify?: { path: string; content: string }[];
	filesToCreate?: { path: string; content: string }[];
	filesToDelete?: string[];
	agentId?: string;
	agentName?: string;
}

================
File: services/diffService.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { FileChange } from '../models/types';

/**
 * Service for generating and managing diffs between files
 */
export class DiffService {
	private static instance: DiffService | null = null;

	private constructor() {}

	/**
	 * Get the singleton instance of the DiffService
	 * @returns DiffService instance
	 */
	public static getInstance(): DiffService {
		if (!DiffService.instance) {
			DiffService.instance = new DiffService();
		}
		return DiffService.instance;
	}

	/**
	 * Generate hunks for a file change by comparing original and modified content using Myers diff algorithm
	 * @param originalContent The original file content
	 * @param modifiedContent The modified file content
	 * @returns An array of hunks representing the changes
	 */
	public generateHunks(
		originalContent: string,
		modifiedContent: string,
	): Array<{
		startLine: number;
		endLine: number;
		content: string;
		originalContent: string;
		semanticGroup?: string;
	}> {
		// Split the content into lines
		const originalLines = originalContent.split('\n');
		const modifiedLines = modifiedContent.split('\n');

		// Compute the diff using Myers algorithm
		const diff = this.myersDiff(originalLines, modifiedLines);

		// Convert diff to hunks
		const hunks: Array<{
			startLine: number;
			endLine: number;
			content: string;
			originalContent: string;
			semanticGroup?: string;
		}> = [];

		let currentHunk: {
			startLine: number;
			endLine: number;
			content: string[];
			originalContent: string[];
		} | null = null;

		let i = 0;
		let j = 0;

		for (const d of diff) {
			if (d.type === 'equal') {
				// If we have a current hunk, finalize it
				if (currentHunk) {
					hunks.push({
						startLine: currentHunk.startLine,
						endLine: currentHunk.endLine,
						content: currentHunk.content.join('\n'),
						originalContent: currentHunk.originalContent.join('\n'),
					});
					currentHunk = null;
				}

				// Skip equal lines
				i += d.count;
				j += d.count;
			} else if (d.type === 'insert') {
				// Start a new hunk if needed
				if (!currentHunk) {
					currentHunk = {
						startLine: i + 1, // 1-indexed
						endLine: i + 1,
						content: [],
						originalContent: [],
					};
				}

				// Add inserted lines to the hunk
				for (let k = 0; k < d.count; k++) {
					currentHunk.content.push(modifiedLines[j + k]);
					currentHunk.originalContent.push('');
				}

				// Update the end line
				currentHunk.endLine = i + 1;

				// Move the modified content pointer
				j += d.count;
			} else if (d.type === 'delete') {
				// Start a new hunk if needed
				if (!currentHunk) {
					currentHunk = {
						startLine: i + 1, // 1-indexed
						endLine: i + d.count,
						content: [],
						originalContent: [],
					};
				}

				// Add deleted lines to the hunk
				for (let k = 0; k < d.count; k++) {
					currentHunk.content.push('');
					currentHunk.originalContent.push(originalLines[i + k]);
				}

				// Update the end line
				currentHunk.endLine = i + d.count;

				// Move the original content pointer
				i += d.count;
			} else if (d.type === 'replace') {
				// Start a new hunk if needed
				if (!currentHunk) {
					currentHunk = {
						startLine: i + 1, // 1-indexed
						endLine: i + d.count,
						content: [],
						originalContent: [],
					};
				}

				// Add replaced lines to the hunk
				for (let k = 0; k < d.count; k++) {
					currentHunk.content.push(modifiedLines[j + k]);
					currentHunk.originalContent.push(originalLines[i + k]);
				}

				// Update the end line
				currentHunk.endLine = i + d.count;

				// Move both pointers
				i += d.count;
				j += d.count;
			}
		}

		// Finalize the last hunk if needed
		if (currentHunk) {
			hunks.push({
				startLine: currentHunk.startLine,
				endLine: currentHunk.endLine,
				content: currentHunk.content.join('\n'),
				originalContent: currentHunk.originalContent.join('\n'),
			});
		}

		// Apply semantic grouping to the hunks
		return this.applySemanticGrouping(hunks, originalContent, modifiedContent);
	}

	/**
	 * Generate a FileChange object for a file
	 * @param filePath Path to the file
	 * @param originalContent Original content of the file
	 * @param modifiedContent Modified content of the file
	 * @returns FileChange object
	 */
	public generateFileChange(filePath: string, originalContent: string, modifiedContent: string): FileChange {
		const hunks = this.generateHunks(originalContent, modifiedContent);

		return {
			path: filePath,
			content: modifiedContent,
			originalContent,
			type: 'modify',
		};
	}

	/**
	 * Show a diff between two contents in VS Code
	 * @param originalContent Original content
	 * @param modifiedContent Modified content
	 * @param title Title for the diff view
	 */
	public async showDiff(originalContent: string, modifiedContent: string, title: string): Promise<void> {
		// Create temporary URIs for the diff
		const originalUri = vscode.Uri.parse(`untitled:Original-${title}`);
		const modifiedUri = vscode.Uri.parse(`untitled:Modified-${title}`);

		// Show the diff
		const diff = await vscode.commands.executeCommand('vscode.diff', originalUri, modifiedUri, `Diff: ${title}`, {
			preview: true,
		});

		// Create the documents with the content
		const originalDoc = await vscode.workspace.openTextDocument(originalUri);
		const modifiedDoc = await vscode.workspace.openTextDocument(modifiedUri);

		// Edit the documents to add the content
		const originalEdit = new vscode.WorkspaceEdit();
		const modifiedEdit = new vscode.WorkspaceEdit();

		originalEdit.insert(originalUri, new vscode.Position(0, 0), originalContent);
		modifiedEdit.insert(modifiedUri, new vscode.Position(0, 0), modifiedContent);

		await vscode.workspace.applyEdit(originalEdit);
		await vscode.workspace.applyEdit(modifiedEdit);
	}

	/**
	 * Get the content of a file
	 * @param filePath Path to the file
	 * @returns File content or null if the file doesn't exist
	 */
	public getFileContent(filePath: string): string | null {
		try {
			// Get the workspace folder
			const workspaceFolders = vscode.workspace.workspaceFolders;
			if (!workspaceFolders || workspaceFolders.length === 0) {
				return null;
			}

			// Resolve the file path
			const absolutePath = path.join(workspaceFolders[0].uri.fsPath, filePath);

			// Check if the file exists
			if (!fs.existsSync(absolutePath)) {
				return null;
			}

			// Read the file content
			return fs.readFileSync(absolutePath, 'utf8');
		} catch (error) {
			console.error(`Error reading file ${filePath}:`, error);
			return null;
		}
	}

	/**
	 * Apply a file change to the workspace
	 * @param fileChange FileChange object
	 * @returns True if the change was applied successfully
	 */
	public applyFileChange(fileChange: FileChange): boolean {
		try {
			// Get the workspace folder
			const workspaceFolders = vscode.workspace.workspaceFolders;
			if (!workspaceFolders || workspaceFolders.length === 0) {
				return false;
			}

			// Resolve the file path
			const absolutePath = path.join(workspaceFolders[0].uri.fsPath, fileChange.path);

			// Create the directory if it doesn't exist
			const directory = path.dirname(absolutePath);
			if (!fs.existsSync(directory)) {
				fs.mkdirSync(directory, { recursive: true });
			}

			// Write the file content
			fs.writeFileSync(absolutePath, fileChange.content, 'utf8');

			return true;
		} catch (error) {
			console.error(`Error applying file change to ${fileChange.path}:`, error);
			return false;
		}
	}

	/**
	 * Delete a file from the workspace
	 * @param filePath Path to the file
	 * @returns True if the file was deleted successfully
	 */
	public deleteFile(filePath: string): boolean {
		try {
			// Get the workspace folder
			const workspaceFolders = vscode.workspace.workspaceFolders;
			if (!workspaceFolders || workspaceFolders.length === 0) {
				return false;
			}

			// Resolve the file path
			const absolutePath = path.join(workspaceFolders[0].uri.fsPath, filePath);

			// Check if the file exists
			if (!fs.existsSync(absolutePath)) {
				return false;
			}

			// Delete the file
			fs.unlinkSync(absolutePath);

			return true;
		} catch (error) {
			console.error(`Error deleting file ${filePath}:`, error);
			return false;
		}
	}

	/**
	 * Group changes by feature
	 * @param changeGroups Array of change groups
	 * @returns Record of feature names to change groups
	 */
	public groupChangesByFeature(changeGroups: any[]): Record<string, any[]> {
		const groupedChanges: Record<string, any[]> = {};

		for (const group of changeGroups) {
			// Extract feature names from the title and description
			const featureNames = this.extractFeatureNames(group.title, group.description);

			// If no features were extracted, use a default feature
			if (featureNames.length === 0) {
				featureNames.push('General');
			}

			// Add the group to each feature
			for (const feature of featureNames) {
				if (!groupedChanges[feature]) {
					groupedChanges[feature] = [];
				}
				groupedChanges[feature].push(group);
			}
		}

		return groupedChanges;
	}

	/**
	 * Apply semantic grouping to hunks
	 * @param hunks Array of hunks
	 * @param originalContent Original content
	 * @param modifiedContent Modified content
	 * @returns Array of hunks with semantic grouping
	 */
	private applySemanticGrouping(
		hunks: Array<{
			startLine: number;
			endLine: number;
			content: string;
			originalContent: string;
			semanticGroup?: string;
		}>,
		originalContent: string,
		modifiedContent: string,
	): Array<{
		startLine: number;
		endLine: number;
		content: string;
		originalContent: string;
		semanticGroup?: string;
	}> {
		// Identify code structures in the original content
		const codeStructures = this.identifyCodeStructures(originalContent, modifiedContent);

		// Apply semantic grouping to hunks
		for (const hunk of hunks) {
			// Find the code structure that contains this hunk
			for (const structure of codeStructures) {
				if (hunk.startLine >= structure.startLine && hunk.endLine <= structure.endLine) {
					hunk.semanticGroup = structure.name;
					break;
				}
			}

			// If no semantic group was assigned, use a default
			if (!hunk.semanticGroup) {
				hunk.semanticGroup = 'General';
			}
		}

		return hunks;
	}

	/**
	 * Identify code structures in the content
	 * @param originalContent Original content
	 * @param modifiedContent Modified content
	 * @returns Array of code structures
	 */
	private identifyCodeStructures(
		originalContent: string,
		modifiedContent: string,
	): Array<{ name: string; startLine: number; endLine: number }> {
		const structures: Array<{ name: string; startLine: number; endLine: number }> = [];
		const lines = originalContent.split('\n');

		// Simple regex patterns to identify common code structures
		const patterns = [
			{ type: 'function', regex: /^\s*(function|const|let|var|async)\s+(\w+)\s*\(.*\)\s*{/i },
			{ type: 'class', regex: /^\s*class\s+(\w+)/ },
			{ type: 'method', regex: /^\s*(\w+)\s*\(.*\)\s*{/i },
			{ type: 'import', regex: /^\s*import\s+.*/ },
			{ type: 'export', regex: /^\s*export\s+.*/ },
			{ type: 'interface', regex: /^\s*interface\s+(\w+)/ },
			{ type: 'type', regex: /^\s*type\s+(\w+)/ },
			{ type: 'enum', regex: /^\s*enum\s+(\w+)/ },
		];

		// Stack to track nested structures
		const stack: Array<{ type: string; name: string; startLine: number }> = [];

		// Process each line
		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];

			// Check for structure start
			for (const pattern of patterns) {
				const match = line.match(pattern.regex);
				if (match) {
					const name = match[1] || match[0];
					stack.push({ type: pattern.type, name, startLine: i + 1 });
					break;
				}
			}

			// Check for structure end (simple heuristic: closing brace at the same indentation level)
			if (line.match(/^\s*}\s*$/) && stack.length > 0) {
				const structure = stack.pop();
				if (structure) {
					structures.push({
						name: `${structure.type}:${structure.name}`,
						startLine: structure.startLine,
						endLine: i + 1,
					});
				}
			}
		}

		return structures;
	}

	/**
	 * Compute the diff between two arrays using Myers diff algorithm
	 * @param a First array
	 * @param b Second array
	 * @returns Array of diff operations
	 */
	private myersDiff(
		a: string[],
		b: string[],
	): Array<{ type: 'equal' | 'insert' | 'delete' | 'replace'; count: number }> {
		const n = a.length;
		const m = b.length;
		const max = n + m;
		const v = new Array(2 * max + 1).fill(0);
		const trace: number[][] = [];

		// Compute the shortest edit script
		for (let d = 0; d <= max; d++) {
			trace.push([...v]);
			for (let k = -d; k <= d; k += 2) {
				let x;
				if (k === -d || (k !== d && v[max + k - 1] < v[max + k + 1])) {
					x = v[max + k + 1];
				} else {
					x = v[max + k - 1] + 1;
				}
				let y = x - k;
				while (x < n && y < m && a[x] === b[y]) {
					x++;
					y++;
				}
				v[max + k] = x;
				if (x >= n && y >= m) {
					// Found the shortest edit script
					return this.backtrack(a, b, trace, d);
				}
			}
		}

		// Fallback: return a simple replace operation
		return [{ type: 'replace', count: Math.max(n, m) }];
	}

	/**
	 * Backtrack through the trace to build the diff
	 * @param a First array
	 * @param b Second array
	 * @param trace Trace of the diff computation
	 * @param d Final edit distance
	 * @returns Array of diff operations
	 */
	private backtrack(
		a: string[],
		b: string[],
		trace: number[][],
		d: number,
	): Array<{ type: 'equal' | 'insert' | 'delete' | 'replace'; count: number }> {
		const result: Array<{ type: 'equal' | 'insert' | 'delete' | 'replace'; count: number }> = [];
		const max = a.length + b.length;
		let x = a.length;
		let y = b.length;

		// Backtrack through the trace
		for (let i = d; i > 0; i--) {
			const v = trace[i];
			const k = x - y;
			let prevK;

			if (k === -i || (k !== i && v[max + k - 1] < v[max + k + 1])) {
				prevK = k + 1;
			} else {
				prevK = k - 1;
			}

			const prevX = v[max + prevK];
			const prevY = prevX - prevK;

			while (x > prevX && y > prevY) {
				// Equal elements
				result.unshift({ type: 'equal', count: 1 });
				x--;
				y--;
			}

			if (i > 0) {
				if (x === prevX) {
					// Insert
					result.unshift({ type: 'insert', count: 1 });
					y--;
				} else {
					// Delete
					result.unshift({ type: 'delete', count: 1 });
					x--;
				}
			}
		}

		// Handle remaining equal elements
		while (x > 0 && y > 0) {
			if (a[x - 1] === b[y - 1]) {
				result.unshift({ type: 'equal', count: 1 });
				x--;
				y--;
			} else {
				// Replace
				result.unshift({ type: 'replace', count: 1 });
				x--;
				y--;
			}
		}

		// Handle remaining elements
		if (x > 0) {
			result.unshift({ type: 'delete', count: x });
		}
		if (y > 0) {
			result.unshift({ type: 'insert', count: y });
		}

		// Merge consecutive operations of the same type
		const merged: Array<{ type: 'equal' | 'insert' | 'delete' | 'replace'; count: number }> = [];
		let current: { type: 'equal' | 'insert' | 'delete' | 'replace'; count: number } | null = null;

		for (const op of result) {
			if (!current) {
				current = { ...op };
			} else if (current.type === op.type) {
				current.count += op.count;
			} else {
				merged.push(current);
				current = { ...op };
			}
		}

		if (current) {
			merged.push(current);
		}

		return merged;
	}

	/**
	 * Extract feature names from title and description
	 * @param title Title of the change
	 * @param description Description of the change
	 * @returns Array of feature names
	 */
	private extractFeatureNames(title: string, description: string): string[] {
		const featureNames: string[] = [];
		const combinedText = `${title} ${description}`;

		// Extract feature names using common patterns
		const patterns = [
			/feature[:\s]+([a-z0-9\s_-]+)/i,
			/implement[:\s]+([a-z0-9\s_-]+)/i,
			/add[:\s]+([a-z0-9\s_-]+)/i,
			/enhance[:\s]+([a-z0-9\s_-]+)/i,
			/improve[:\s]+([a-z0-9\s_-]+)/i,
			/refactor[:\s]+([a-z0-9\s_-]+)/i,
			/fix[:\s]+([a-z0-9\s_-]+)/i,
		];

		for (const pattern of patterns) {
			const match = combinedText.match(pattern);
			if (match && match[1]) {
				featureNames.push(match[1].trim());
			}
		}

		// If no features were extracted, use the title as a feature
		if (featureNames.length === 0 && title) {
			featureNames.push(title);
		}

		return featureNames;
	}
}

================
File: services/storageService.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import {
	ChangeGroup,
	Checkpoint,
	Annotation,
	Implementation,
	Conflict,
	SubCheckpoint,
	FileChange,
	AnnotationReply,
} from '../models/types';
import { STORAGE_PATHS, getStorageDirectory } from '../config';

/**
 * Service for managing persistent storage of extension data
 */
export class StorageService {
	private static instance: StorageService | null = null;
	private context: vscode.ExtensionContext;
	private storageDir: string;

	private constructor(context: vscode.ExtensionContext) {
		this.context = context;
		this.storageDir = getStorageDirectory();
		this.initializeStorage();
	}

	/**
	 * Get the singleton instance of the StorageService
	 * @param context Extension context
	 * @returns StorageService instance
	 */
	public static getInstance(context?: vscode.ExtensionContext): StorageService {
		if (!StorageService.instance) {
			if (!context) {
				throw new Error('StorageService must be initialized with an extension context');
			}
			StorageService.instance = new StorageService(context);
		}
		return StorageService.instance;
	}

	/**
	 * Initialize the storage directories
	 */
	private initializeStorage(): void {
		try {
			// Create the base storage directory if it doesn't exist
			if (!fs.existsSync(this.storageDir)) {
				fs.mkdirSync(this.storageDir, { recursive: true });
			}

			// Create subdirectories for different types of data
			const subdirs = [
				STORAGE_PATHS.CHANGE_GROUPS,
				STORAGE_PATHS.CHECKPOINTS,
				STORAGE_PATHS.ANNOTATIONS,
				STORAGE_PATHS.IMPLEMENTATIONS,
				STORAGE_PATHS.CONFLICTS,
				STORAGE_PATHS.HISTORY,
			];

			for (const subdir of subdirs) {
				const fullPath = path.join(this.storageDir, subdir);
				if (!fs.existsSync(fullPath)) {
					fs.mkdirSync(fullPath, { recursive: true });
				}
			}
		} catch (error) {
			console.error('Error initializing storage:', error);
			throw error;
		}
	}

	/**
	 * Get all change groups
	 * @returns Array of change groups
	 */
	public async getChangeGroups(): Promise<ChangeGroup[]> {
		try {
			const changeGroupsDir = path.join(this.storageDir, STORAGE_PATHS.CHANGE_GROUPS);
			const files = fs.readdirSync(changeGroupsDir);
			const changeGroups: ChangeGroup[] = [];

			for (const file of files) {
				if (file.endsWith('.json')) {
					const filePath = path.join(changeGroupsDir, file);
					const content = fs.readFileSync(filePath, 'utf8');
					const changeGroup = JSON.parse(content) as ChangeGroup;
					changeGroups.push(changeGroup);
				}
			}

			return changeGroups;
		} catch (error) {
			console.error('Error getting change groups:', error);
			return [];
		}
	}

	/**
	 * Save a change group
	 * @param changeGroup Change group to save
	 */
	public async saveChangeGroup(changeGroup: ChangeGroup): Promise<void> {
		try {
			const changeGroupsDir = path.join(this.storageDir, STORAGE_PATHS.CHANGE_GROUPS);
			const filePath = path.join(changeGroupsDir, `${changeGroup.id}.json`);
			fs.writeFileSync(filePath, JSON.stringify(changeGroup, null, 2), 'utf8');
		} catch (error) {
			console.error(`Error saving change group ${changeGroup.id}:`, error);
			throw error;
		}
	}

	/**
	 * Delete a change group
	 * @param groupId ID of the change group to delete
	 */
	public async deleteChangeGroup(groupId: string): Promise<void> {
		try {
			const changeGroupsDir = path.join(this.storageDir, STORAGE_PATHS.CHANGE_GROUPS);
			const filePath = path.join(changeGroupsDir, `${groupId}.json`);

			if (fs.existsSync(filePath)) {
				fs.unlinkSync(filePath);
			}
		} catch (error) {
			console.error(`Error deleting change group ${groupId}:`, error);
			throw error;
		}
	}

	/**
	 * Get a change group by ID
	 * @param groupId ID of the change group
	 * @returns Change group or null if not found
	 */
	public async getChangeGroup(groupId: string): Promise<ChangeGroup | null> {
		try {
			const changeGroupsDir = path.join(this.storageDir, STORAGE_PATHS.CHANGE_GROUPS);
			const filePath = path.join(changeGroupsDir, `${groupId}.json`);

			if (!fs.existsSync(filePath)) {
				return null;
			}

			const content = fs.readFileSync(filePath, 'utf8');
			return JSON.parse(content) as ChangeGroup;
		} catch (error) {
			console.error(`Error getting change group ${groupId}:`, error);
			return null;
		}
	}

	/**
	 * Get all checkpoints
	 * @returns Array of checkpoints
	 */
	public async getCheckpoints(): Promise<Checkpoint[]> {
		try {
			const checkpointsDir = path.join(this.storageDir, STORAGE_PATHS.CHECKPOINTS);
			const files = fs.readdirSync(checkpointsDir);
			const checkpoints: Checkpoint[] = [];

			for (const file of files) {
				if (file.endsWith('.json') && !file.includes('snapshot')) {
					const filePath = path.join(checkpointsDir, file);
					const content = fs.readFileSync(filePath, 'utf8');
					const checkpoint = JSON.parse(content) as Checkpoint;
					checkpoints.push(checkpoint);
				}
			}

			return checkpoints;
		} catch (error) {
			console.error('Error getting checkpoints:', error);
			return [];
		}
	}

	/**
	 * Save a checkpoint
	 * @param checkpoint Checkpoint to save
	 * @param snapshot Snapshot data
	 */
	public async saveCheckpoint(checkpoint: Checkpoint, snapshot: Record<string, string>): Promise<void> {
		try {
			const checkpointsDir = path.join(this.storageDir, STORAGE_PATHS.CHECKPOINTS);

			// Save the checkpoint metadata
			const metadataPath = path.join(checkpointsDir, `${checkpoint.id}.json`);

			// Save the snapshot data
			const snapshotPath = path.join(checkpointsDir, `${checkpoint.id}-snapshot.json`);
			fs.writeFileSync(snapshotPath, JSON.stringify(snapshot, null, 2), 'utf8');

			// Update the checkpoint with the snapshot path
			checkpoint.snapshotPath = snapshotPath;

			// Save the updated checkpoint metadata
			fs.writeFileSync(metadataPath, JSON.stringify(checkpoint, null, 2), 'utf8');
		} catch (error) {
			console.error(`Error saving checkpoint ${checkpoint.id}:`, error);
			throw error;
		}
	}

	/**
	 * Delete a checkpoint
	 * @param checkpointId ID of the checkpoint to delete
	 */
	public async deleteCheckpoint(checkpointId: string): Promise<void> {
		try {
			const checkpointsDir = path.join(this.storageDir, STORAGE_PATHS.CHECKPOINTS);
			const metadataPath = path.join(checkpointsDir, `${checkpointId}.json`);
			const snapshotPath = path.join(checkpointsDir, `${checkpointId}-snapshot.json`);

			// Delete the checkpoint metadata
			if (fs.existsSync(metadataPath)) {
				fs.unlinkSync(metadataPath);
			}

			// Delete the snapshot data
			if (fs.existsSync(snapshotPath)) {
				fs.unlinkSync(snapshotPath);
			}
		} catch (error) {
			console.error(`Error deleting checkpoint ${checkpointId}:`, error);
			throw error;
		}
	}

	/**
	 * Get a checkpoint snapshot
	 * @param checkpointId ID of the checkpoint
	 * @returns Snapshot data
	 */
	public async getCheckpointSnapshot(checkpointId: string): Promise<Record<string, string>> {
		try {
			const checkpointsDir = path.join(this.storageDir, STORAGE_PATHS.CHECKPOINTS);
			const snapshotPath = path.join(checkpointsDir, `${checkpointId}-snapshot.json`);

			if (!fs.existsSync(snapshotPath)) {
				throw new Error(`Snapshot not found for checkpoint ${checkpointId}`);
			}

			const content = fs.readFileSync(snapshotPath, 'utf8');
			return JSON.parse(content) as Record<string, string>;
		} catch (error) {
			console.error(`Error getting checkpoint snapshot ${checkpointId}:`, error);
			throw error;
		}
	}

	/**
	 * Create a workspace snapshot
	 * @returns Snapshot data
	 */
	public async createWorkspaceSnapshot(): Promise<Record<string, string>> {
		try {
			const snapshot: Record<string, string> = {};
			const workspaceFolders = vscode.workspace.workspaceFolders;

			if (!workspaceFolders || workspaceFolders.length === 0) {
				throw new Error('No workspace folder is open');
			}

			const workspaceRoot = workspaceFolders[0].uri.fsPath;

			// Recursively scan the workspace
			this.scanDirectory(workspaceRoot, '', snapshot);

			return snapshot;
		} catch (error) {
			console.error('Error creating workspace snapshot:', error);
			throw error;
		}
	}

	/**
	 * Restore workspace from a snapshot
	 * @param snapshot Snapshot data
	 */
	public async restoreWorkspaceFromSnapshot(snapshot: Record<string, string>): Promise<void> {
		try {
			const workspaceFolders = vscode.workspace.workspaceFolders;

			if (!workspaceFolders || workspaceFolders.length === 0) {
				throw new Error('No workspace folder is open');
			}

			const workspaceRoot = workspaceFolders[0].uri.fsPath;

			// Restore each file in the snapshot
			for (const [relativePath, content] of Object.entries(snapshot)) {
				const absolutePath = path.join(workspaceRoot, relativePath);
				const directory = path.dirname(absolutePath);

				// Create the directory if it doesn't exist
				if (!fs.existsSync(directory)) {
					fs.mkdirSync(directory, { recursive: true });
				}

				// Write the file content
				fs.writeFileSync(absolutePath, content, 'utf8');
			}
		} catch (error) {
			console.error('Error restoring workspace from snapshot:', error);
			throw error;
		}
	}

	/**
	 * Create a sub-checkpoint
	 * @param parentCheckpointId ID of the parent checkpoint
	 * @param description Description of the sub-checkpoint
	 * @param changes Changes to include in the sub-checkpoint
	 * @returns Created sub-checkpoint
	 */
	public async createSubCheckpoint(
		parentCheckpointId: string,
		description: string,
		changes: FileChange[] | { modified: string[]; created: string[]; deleted: string[] },
	): Promise<SubCheckpoint> {
		try {
			// Get the parent checkpoint
			const metadataPath = path.join(
				getStorageDirectory(),
				STORAGE_PATHS.CHECKPOINTS,
				`${parentCheckpointId}.json`,
			);

			if (!fs.existsSync(metadataPath)) {
				throw new Error(`Parent checkpoint ${parentCheckpointId} not found`);
			}

			const content = fs.readFileSync(metadataPath, 'utf8');
			const parentCheckpoint = JSON.parse(content) as Checkpoint;

			// Convert changes to FileChange[] if needed
			let fileChanges: FileChange[] = [];
			if (Array.isArray(changes)) {
				fileChanges = changes;
			} else {
				// Convert the changes object to FileChange[]
				const { modified, created, deleted } = changes;

				// Add modified files
				if (modified && Array.isArray(modified)) {
					for (const path of modified) {
						fileChanges.push({
							path,
							content: '',
							type: 'modify',
						});
					}
				}

				// Add created files
				if (created && Array.isArray(created)) {
					for (const path of created) {
						fileChanges.push({
							path,
							content: '',
							type: 'create',
						});
					}
				}

				// Add deleted files
				if (deleted && Array.isArray(deleted)) {
					for (const path of deleted) {
						fileChanges.push({
							path,
							content: '',
							type: 'delete',
						});
					}
				}
			}

			// Create the sub-checkpoint
			const subCheckpoint: SubCheckpoint = {
				id: `sub-${Date.now()}`,
				timestamp: new Date().toISOString(),
				description,
				parentCheckpointId,
				changes: fileChanges,
			};

			// Add the sub-checkpoint to the parent
			if (!parentCheckpoint.subCheckpoints) {
				parentCheckpoint.subCheckpoints = [];
			}

			parentCheckpoint.subCheckpoints.push(subCheckpoint);

			// Save the updated parent checkpoint
			await fs.promises.writeFile(metadataPath, JSON.stringify(parentCheckpoint, null, 2));

			return subCheckpoint;
		} catch (error) {
			console.error(`Error creating sub-checkpoint for ${parentCheckpointId}:`, error);
			throw error;
		}
	}

	/**
	 * Get all annotations
	 * @returns Array of annotations
	 */
	public async getAnnotations(): Promise<Annotation[]> {
		try {
			const annotationsDir = path.join(this.storageDir, STORAGE_PATHS.ANNOTATIONS);
			const files = fs.readdirSync(annotationsDir);
			const annotations: Annotation[] = [];

			for (const file of files) {
				if (file.endsWith('.json')) {
					const filePath = path.join(annotationsDir, file);
					const content = fs.readFileSync(filePath, 'utf8');
					const annotation = JSON.parse(content) as Annotation;
					annotations.push(annotation);
				}
			}

			return annotations;
		} catch (error) {
			console.error('Error getting annotations:', error);
			return [];
		}
	}

	/**
	 * Save an annotation
	 * @param annotation Annotation to save
	 */
	public async saveAnnotation(annotation: Annotation): Promise<void> {
		try {
			const annotationsDir = path.join(this.storageDir, STORAGE_PATHS.ANNOTATIONS);
			const filePath = path.join(annotationsDir, `${annotation.id}.json`);
			fs.writeFileSync(filePath, JSON.stringify(annotation, null, 2), 'utf8');
		} catch (error) {
			console.error(`Error saving annotation ${annotation.id}:`, error);
			throw error;
		}
	}

	/**
	 * Delete an annotation
	 * @param annotationId ID of the annotation to delete
	 */
	public async deleteAnnotation(annotationId: string): Promise<void> {
		try {
			const annotationsDir = path.join(this.storageDir, STORAGE_PATHS.ANNOTATIONS);
			const filePath = path.join(annotationsDir, `${annotationId}.json`);

			if (fs.existsSync(filePath)) {
				fs.unlinkSync(filePath);
			}
		} catch (error) {
			console.error(`Error deleting annotation ${annotationId}:`, error);
			throw error;
		}
	}

	/**
	 * Save all annotations to storage
	 * @param annotations Annotations to save
	 */
	public async saveAnnotations(annotations: Annotation[]): Promise<void> {
		try {
			const annotationsPath = path.join(getStorageDirectory(), STORAGE_PATHS.ANNOTATIONS);
			await fs.promises.writeFile(annotationsPath, JSON.stringify(annotations, null, 2));
		} catch (error) {
			console.error('Error saving annotations:', error);
			throw error;
		}
	}

	/**
	 * Add a reply to an annotation
	 * @param parentId ID of the parent annotation
	 * @param reply Reply to add
	 */
	public async addReplyToAnnotation(parentId: string, reply: AnnotationReply): Promise<void> {
		try {
			// Helper function to find and update an annotation
			const findAndUpdate = (annotations: Annotation[]): boolean => {
				for (const annotation of annotations) {
					if (annotation.id === parentId) {
						if (!annotation.replies) {
							annotation.replies = [];
						}
						annotation.replies.push(reply);
						return true;
					}
					// Check if this annotation has replies that might contain our target
					if (annotation.replies && annotation.replies.length > 0) {
						// We need to check if any of the replies is our target parent
						// Since replies can also be annotations (with nested replies)
						const nestedAnnotations = annotation.replies.filter((r): r is Annotation => 'replies' in r);

						if (nestedAnnotations.length > 0 && findAndUpdate(nestedAnnotations)) {
							return true;
						}
					}
				}
				return false;
			};

			// Get all annotations
			const annotations = await this.getAnnotations();

			// Find and update the parent annotation
			if (findAndUpdate(annotations)) {
				// Save the updated annotations
				await this.saveAnnotations(annotations);
			}
		} catch (error) {
			console.error('Error adding reply to annotation:', error);
			throw error;
		}
	}

	/**
	 * Get all implementations
	 * @returns Array of implementations
	 */
	public async getImplementations(): Promise<Implementation[]> {
		try {
			const implementationsDir = path.join(this.storageDir, STORAGE_PATHS.IMPLEMENTATIONS);
			const files = fs.readdirSync(implementationsDir);
			const implementations: Implementation[] = [];

			for (const file of files) {
				if (file.endsWith('.json')) {
					const filePath = path.join(implementationsDir, file);
					const content = fs.readFileSync(filePath, 'utf8');
					const implementation = JSON.parse(content) as Implementation;
					implementations.push(implementation);
				}
			}

			return implementations;
		} catch (error) {
			console.error('Error getting implementations:', error);
			return [];
		}
	}

	/**
	 * Save an implementation
	 * @param implementation Implementation to save
	 */
	public async saveImplementation(implementation: Implementation): Promise<void> {
		try {
			const implementationsDir = path.join(this.storageDir, STORAGE_PATHS.IMPLEMENTATIONS);
			const filePath = path.join(implementationsDir, `${implementation.id}.json`);
			fs.writeFileSync(filePath, JSON.stringify(implementation, null, 2), 'utf8');
		} catch (error) {
			console.error(`Error saving implementation ${implementation.id}:`, error);
			throw error;
		}
	}

	/**
	 * Delete an implementation
	 * @param implementationId ID of the implementation to delete
	 */
	public async deleteImplementation(implementationId: string): Promise<void> {
		try {
			const implementationsDir = path.join(this.storageDir, STORAGE_PATHS.IMPLEMENTATIONS);
			const filePath = path.join(implementationsDir, `${implementationId}.json`);

			if (fs.existsSync(filePath)) {
				fs.unlinkSync(filePath);
			}
		} catch (error) {
			console.error(`Error deleting implementation ${implementationId}:`, error);
			throw error;
		}
	}

	/**
	 * Get all conflicts
	 * @returns Array of conflicts
	 */
	public async getConflicts(): Promise<Conflict[]> {
		try {
			const conflictsDir = path.join(this.storageDir, STORAGE_PATHS.CONFLICTS);
			const files = fs.readdirSync(conflictsDir);
			const conflicts: Conflict[] = [];

			for (const file of files) {
				if (file.endsWith('.json')) {
					const filePath = path.join(conflictsDir, file);
					const content = fs.readFileSync(filePath, 'utf8');
					const conflict = JSON.parse(content) as Conflict;
					conflicts.push(conflict);
				}
			}

			return conflicts;
		} catch (error) {
			console.error('Error getting conflicts:', error);
			return [];
		}
	}

	/**
	 * Save a conflict
	 * @param conflict Conflict to save
	 */
	public async saveConflict(conflict: Conflict): Promise<void> {
		try {
			const conflictsDir = path.join(this.storageDir, STORAGE_PATHS.CONFLICTS);
			const filePath = path.join(conflictsDir, `${conflict.id}.json`);
			fs.writeFileSync(filePath, JSON.stringify(conflict, null, 2), 'utf8');
		} catch (error) {
			console.error(`Error saving conflict ${conflict.id}:`, error);
			throw error;
		}
	}

	/**
	 * Delete a conflict
	 * @param conflictId ID of the conflict to delete
	 */
	public async deleteConflict(conflictId: string): Promise<void> {
		try {
			const conflictsDir = path.join(this.storageDir, STORAGE_PATHS.CONFLICTS);
			const filePath = path.join(conflictsDir, `${conflictId}.json`);

			if (fs.existsSync(filePath)) {
				fs.unlinkSync(filePath);
			}
		} catch (error) {
			console.error(`Error deleting conflict ${conflictId}:`, error);
			throw error;
		}
	}

	/**
	 * Resolve a conflict automatically
	 * @param conflictId ID of the conflict to resolve
	 * @param preference Preference for resolution ('agent' or 'user')
	 * @returns Resolved conflict with changes
	 */
	public async resolveConflictAutomatically(
		conflictId: string,
		preference: 'agent' | 'user' = 'agent',
	): Promise<FileChange[]> {
		try {
			// Get the conflict
			const conflicts = await this.getConflicts();
			const conflict = conflicts.find((c) => c.id === conflictId);

			if (!conflict) {
				throw new Error(`Conflict ${conflictId} not found`);
			}

			// Determine which changes to use based on preference
			const resolvedChanges: FileChange[] =
				preference === 'agent' ? [...conflict.agentChanges] : [...conflict.userChanges];

			// Update the conflict with resolved information
			conflict.resolvedChanges = resolvedChanges;
			conflict.resolutionStrategy = 'auto';
			conflict.resolutionTimestamp = new Date().toISOString();
			conflict.status = 'resolved' as const;
			conflict.resolvedContent =
				preference === 'agent'
					? conflict.agentChanges[0]?.content || null
					: conflict.userChanges[0]?.content || null;

			// Save the updated conflict
			await this.saveConflict(conflict);

			return resolvedChanges;
		} catch (error) {
			console.error(`Error resolving conflict ${conflictId}:`, error);
			throw error;
		}
	}

	/**
	 * Calculate diff between two snapshots
	 * @param snapshot1 First snapshot
	 * @param snapshot2 Second snapshot
	 * @returns Diff result
	 */
	public calculateDiff(
		snapshot1: Record<string, string>,
		snapshot2: Record<string, string>,
	): {
		modified: string[];
		created: string[];
		deleted: string[];
	} {
		const modified: string[] = [];
		const created: string[] = [];
		const deleted: string[] = [];

		// Find modified and deleted files
		for (const [path, content] of Object.entries(snapshot1)) {
			if (path in snapshot2) {
				if (content !== snapshot2[path]) {
					modified.push(path);
				}
			} else {
				deleted.push(path);
			}
		}

		// Find created files
		for (const path of Object.keys(snapshot2)) {
			if (!(path in snapshot1)) {
				created.push(path);
			}
		}

		return { modified, created, deleted };
	}

	/**
	 * Group file changes by feature
	 * @param fileChanges Array of file changes
	 * @returns Grouped file changes
	 */
	public groupFileChangesByFeature(fileChanges: FileChange[]): Record<string, FileChange[]> {
		const groupedChanges: Record<string, FileChange[]> = {};

		for (const fileChange of fileChanges) {
			// Extract feature names from the file path
			const featureNames = this.extractFeatureNames(fileChange.path);

			// If no features were extracted, use a default feature
			if (featureNames.length === 0) {
				featureNames.push('General');
			}

			// Add the file change to each feature
			for (const feature of featureNames) {
				if (!groupedChanges[feature]) {
					groupedChanges[feature] = [];
				}
				groupedChanges[feature].push(fileChange);
			}
		}

		return groupedChanges;
	}

	/**
	 * Extract feature names from a file path
	 * @param filePath File path
	 * @returns Array of feature names
	 */
	private extractFeatureNames(filePath: string): string[] {
		const featureNames: string[] = [];

		// Extract feature names from directory structure
		const parts = filePath.split('/');

		// Common feature directories
		const featureDirs = ['features', 'modules', 'components', 'services', 'utils', 'helpers'];

		for (let i = 0; i < parts.length - 1; i++) {
			if (featureDirs.includes(parts[i]) && i + 1 < parts.length) {
				featureNames.push(parts[i + 1]);
			}
		}

		return featureNames;
	}

	/**
	 * Scan a directory recursively and add files to the snapshot
	 * @param absolutePath Absolute path to the directory
	 * @param relativePath Relative path to the directory
	 * @param snapshot Snapshot data
	 */
	private scanDirectory(absolutePath: string, relativePath: string, snapshot: Record<string, string>): void {
		const entries = fs.readdirSync(absolutePath, { withFileTypes: true });

		for (const entry of entries) {
			const entryRelativePath = path.join(relativePath, entry.name);
			const entryAbsolutePath = path.join(absolutePath, entry.name);

			if (entry.isDirectory()) {
				// Skip node_modules, .git, and other common directories to ignore
				if (
					entry.name === 'node_modules' ||
					entry.name === '.git' ||
					entry.name === 'dist' ||
					entry.name === 'out'
				) {
					continue;
				}

				// Recursively scan subdirectories
				this.scanDirectory(entryAbsolutePath, entryRelativePath, snapshot);
			} else if (entry.isFile()) {
				// Skip binary files and other files to ignore
				if (
					entry.name.endsWith('.exe') ||
					entry.name.endsWith('.dll') ||
					entry.name.endsWith('.so') ||
					entry.name.endsWith('.dylib')
				) {
					continue;
				}

				// Add the file to the snapshot
				try {
					const content = fs.readFileSync(entryAbsolutePath, 'utf8');
					snapshot[entryRelativePath] = content;
				} catch (error) {
					console.warn(`Skipping binary file: ${entryRelativePath}`);
				}
			}
		}
	}

	/**
	 * Save a history entry
	 * @param historyEntry History entry to save
	 */
	public async saveHistoryEntry(historyEntry: any): Promise<void> {
		try {
			// Get existing history entries
			const historyEntries = await this.getHistoryEntries();

			// Add the new entry
			historyEntries.push(historyEntry);

			// Save the updated history
			const historyPath = path.join(getStorageDirectory(), STORAGE_PATHS.HISTORY);
			await fs.promises.writeFile(historyPath, JSON.stringify(historyEntries, null, 2));
		} catch (error) {
			console.error('Error saving history entry:', error);
			throw error;
		}
	}

	/**
	 * Get all history entries
	 * @returns Array of history entries
	 */
	public async getHistoryEntries(): Promise<any[]> {
		try {
			const historyPath = path.join(getStorageDirectory(), STORAGE_PATHS.HISTORY);

			// Check if the history file exists
			if (!fs.existsSync(historyPath)) {
				return [];
			}

			// Read and parse the history file
			const historyData = await fs.promises.readFile(historyPath, 'utf8');
			return JSON.parse(historyData);
		} catch (error) {
			console.error('Error getting history entries:', error);
			return [];
		}
	}

	/**
	 * Clear all history entries
	 */
	public async clearHistory(): Promise<void> {
		try {
			const historyPath = path.join(getStorageDirectory(), STORAGE_PATHS.HISTORY);

			// Create an empty history file
			await fs.promises.writeFile(historyPath, JSON.stringify([], null, 2));
		} catch (error) {
			console.error('Error clearing history:', error);
			throw error;
		}
	}
}

================
File: test/python_tests/lsp_test_client/__init__.py
================
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.

================
File: test/python_tests/lsp_test_client/constants.py
================
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.
"""
Constants for use with tests.
"""
import pathlib

TEST_ROOT = pathlib.Path(__file__).parent.parent
PROJECT_ROOT = TEST_ROOT.parent.parent.parent
TEST_DATA = TEST_ROOT / "test_data"

================
File: test/python_tests/lsp_test_client/defaults.py
================
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.
"""
Default initialize request params.
"""

import os

from .constants import PROJECT_ROOT
from .utils import as_uri, get_initialization_options

VSCODE_DEFAULT_INITIALIZE = {
    "processId": os.getpid(),
    "clientInfo": {"name": "vscode", "version": "1.45.0"},
    "rootPath": str(PROJECT_ROOT),
    "rootUri": as_uri(str(PROJECT_ROOT)),
    "capabilities": {
        "workspace": {
            "applyEdit": True,
            "workspaceEdit": {
                "documentChanges": True,
                "resourceOperations": ["create", "rename", "delete"],
                "failureHandling": "textOnlyTransactional",
            },
            "didChangeConfiguration": {"dynamicRegistration": True},
            "didChangeWatchedFiles": {"dynamicRegistration": True},
            "symbol": {
                "dynamicRegistration": True,
                "symbolKind": {
                    "valueSet": [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                    ]
                },
                "tagSupport": {"valueSet": [1]},
            },
            "executeCommand": {"dynamicRegistration": True},
            "configuration": True,
            "workspaceFolders": True,
        },
        "textDocument": {
            "publishDiagnostics": {
                "relatedInformation": True,
                "versionSupport": False,
                "tagSupport": {"valueSet": [1, 2]},
                "complexDiagnosticCodeSupport": True,
            },
            "synchronization": {
                "dynamicRegistration": True,
                "willSave": True,
                "willSaveWaitUntil": True,
                "didSave": True,
            },
            "completion": {
                "dynamicRegistration": True,
                "contextSupport": True,
                "completionItem": {
                    "snippetSupport": True,
                    "commitCharactersSupport": True,
                    "documentationFormat": ["markdown", "plaintext"],
                    "deprecatedSupport": True,
                    "preselectSupport": True,
                    "tagSupport": {"valueSet": [1]},
                    "insertReplaceSupport": True,
                },
                "completionItemKind": {
                    "valueSet": [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                    ]
                },
            },
            "hover": {
                "dynamicRegistration": True,
                "contentFormat": ["markdown", "plaintext"],
            },
            "signatureHelp": {
                "dynamicRegistration": True,
                "signatureInformation": {
                    "documentationFormat": ["markdown", "plaintext"],
                    "parameterInformation": {"labelOffsetSupport": True},
                },
                "contextSupport": True,
            },
            "definition": {"dynamicRegistration": True, "linkSupport": True},
            "references": {"dynamicRegistration": True},
            "documentHighlight": {"dynamicRegistration": True},
            "documentSymbol": {
                "dynamicRegistration": True,
                "symbolKind": {
                    "valueSet": [
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        21,
                        22,
                        23,
                        24,
                        25,
                        26,
                    ]
                },
                "hierarchicalDocumentSymbolSupport": True,
                "tagSupport": {"valueSet": [1]},
            },
            "codeAction": {
                "dynamicRegistration": True,
                "isPreferredSupport": True,
                "codeActionLiteralSupport": {
                    "codeActionKind": {
                        "valueSet": [
                            "",
                            "quickfix",
                            "refactor",
                            "refactor.extract",
                            "refactor.inline",
                            "refactor.rewrite",
                            "source",
                            "source.organizeImports",
                        ]
                    }
                },
            },
            "codeLens": {"dynamicRegistration": True},
            "formatting": {"dynamicRegistration": True},
            "rangeFormatting": {"dynamicRegistration": True},
            "onTypeFormatting": {"dynamicRegistration": True},
            "rename": {"dynamicRegistration": True, "prepareSupport": True},
            "documentLink": {
                "dynamicRegistration": True,
                "tooltipSupport": True,
            },
            "typeDefinition": {
                "dynamicRegistration": True,
                "linkSupport": True,
            },
            "implementation": {
                "dynamicRegistration": True,
                "linkSupport": True,
            },
            "colorProvider": {"dynamicRegistration": True},
            "foldingRange": {
                "dynamicRegistration": True,
                "rangeLimit": 5000,
                "lineFoldingOnly": True,
            },
            "declaration": {"dynamicRegistration": True, "linkSupport": True},
            "selectionRange": {"dynamicRegistration": True},
        },
        "window": {"workDoneProgress": True},
    },
    "trace": "verbose",
    "workspaceFolders": [{"uri": as_uri(str(PROJECT_ROOT)), "name": "my_project"}],
    "initializationOptions": get_initialization_options(),
}

================
File: test/python_tests/lsp_test_client/session.py
================
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.
"""
LSP session client for testing.
"""

import os
import subprocess
import sys
from concurrent.futures import Future, ThreadPoolExecutor
from threading import Event

from pyls_jsonrpc.dispatchers import MethodDispatcher
from pyls_jsonrpc.endpoint import Endpoint
from pyls_jsonrpc.streams import JsonRpcStreamReader, JsonRpcStreamWriter

from .constants import PROJECT_ROOT
from .defaults import VSCODE_DEFAULT_INITIALIZE

LSP_EXIT_TIMEOUT = 5000


PUBLISH_DIAGNOSTICS = "textDocument/publishDiagnostics"
WINDOW_LOG_MESSAGE = "window/logMessage"
WINDOW_SHOW_MESSAGE = "window/showMessage"


# pylint: disable=too-many-instance-attributes
class LspSession(MethodDispatcher):
    """Send and Receive messages over LSP as a test LS Client."""

    def __init__(self, cwd=None, script=None):
        self.cwd = cwd if cwd else os.getcwd()
        # pylint: disable=consider-using-with
        self._thread_pool = ThreadPoolExecutor()
        self._sub = None
        self._writer = None
        self._reader = None
        self._endpoint = None
        self._notification_callbacks = {}
        self.script = (
            script if script else (PROJECT_ROOT / "bundled" / "tool" / "lsp_server.py")
        )

    def __enter__(self):
        """Context manager entrypoint.

        shell=True needed for pytest-cov to work in subprocess.
        """
        # pylint: disable=consider-using-with
        self._sub = subprocess.Popen(
            [sys.executable, str(self.script)],
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
            bufsize=0,
            cwd=self.cwd,
            env=os.environ,
            shell="WITH_COVERAGE" in os.environ,
        )

        self._writer = JsonRpcStreamWriter(os.fdopen(self._sub.stdin.fileno(), "wb"))
        self._reader = JsonRpcStreamReader(os.fdopen(self._sub.stdout.fileno(), "rb"))

        dispatcher = {
            PUBLISH_DIAGNOSTICS: self._publish_diagnostics,
            WINDOW_SHOW_MESSAGE: self._window_show_message,
            WINDOW_LOG_MESSAGE: self._window_log_message,
        }
        self._endpoint = Endpoint(dispatcher, self._writer.write)
        self._thread_pool.submit(self._reader.listen, self._endpoint.consume)
        return self

    def __exit__(self, typ, value, _tb):
        self.shutdown(True)
        try:
            self._sub.terminate()
        except Exception:  # pylint:disable=broad-except
            pass
        self._endpoint.shutdown()
        self._thread_pool.shutdown()

    def initialize(
        self,
        initialize_params=None,
        process_server_capabilities=None,
    ):
        """Sends the initialize request to LSP server."""
        if initialize_params is None:
            initialize_params = VSCODE_DEFAULT_INITIALIZE
        server_initialized = Event()

        def _after_initialize(fut):
            if process_server_capabilities:
                process_server_capabilities(fut.result())
            self.initialized()
            server_initialized.set()

        self._send_request(
            "initialize",
            params=(
                initialize_params
                if initialize_params is not None
                else VSCODE_DEFAULT_INITIALIZE
            ),
            handle_response=_after_initialize,
        )

        server_initialized.wait()

    def initialized(self, initialized_params=None):
        """Sends the initialized notification to LSP server."""
        self._endpoint.notify("initialized", initialized_params or {})

    def shutdown(self, should_exit, exit_timeout=LSP_EXIT_TIMEOUT):
        """Sends the shutdown request to LSP server."""

        def _after_shutdown(_):
            if should_exit:
                self.exit_lsp(exit_timeout)

        self._send_request("shutdown", handle_response=_after_shutdown)

    def exit_lsp(self, exit_timeout=LSP_EXIT_TIMEOUT):
        """Handles LSP server process exit."""
        self._endpoint.notify("exit")
        assert self._sub.wait(exit_timeout) == 0

    def notify_did_change(self, did_change_params):
        """Sends did change notification to LSP Server."""
        self._send_notification("textDocument/didChange", params=did_change_params)

    def notify_did_save(self, did_save_params):
        """Sends did save notification to LSP Server."""
        self._send_notification("textDocument/didSave", params=did_save_params)

    def notify_did_open(self, did_open_params):
        """Sends did open notification to LSP Server."""
        self._send_notification("textDocument/didOpen", params=did_open_params)

    def notify_did_close(self, did_close_params):
        """Sends did close notification to LSP Server."""
        self._send_notification("textDocument/didClose", params=did_close_params)

    def text_document_formatting(self, formatting_params):
        """Sends text document references request to LSP server."""
        fut = self._send_request("textDocument/formatting", params=formatting_params)
        return fut.result()

    def text_document_code_action(self, code_action_params):
        """Sends text document code actions request to LSP server."""
        fut = self._send_request("textDocument/codeAction", params=code_action_params)
        return fut.result()

    def code_action_resolve(self, code_action_resolve_params):
        """Sends text document code actions resolve request to LSP server."""
        fut = self._send_request(
            "codeAction/resolve", params=code_action_resolve_params
        )
        return fut.result()

    def set_notification_callback(self, notification_name, callback):
        """Set custom LS notification handler."""
        self._notification_callbacks[notification_name] = callback

    def get_notification_callback(self, notification_name):
        """Gets callback if set or default callback for a given LS
        notification."""
        try:
            return self._notification_callbacks[notification_name]
        except KeyError:

            def _default_handler(_params):
                """Default notification handler."""

            return _default_handler

    def _publish_diagnostics(self, publish_diagnostics_params):
        """Internal handler for text document publish diagnostics."""
        return self._handle_notification(
            PUBLISH_DIAGNOSTICS, publish_diagnostics_params
        )

    def _window_log_message(self, window_log_message_params):
        """Internal handler for window log message."""
        return self._handle_notification(WINDOW_LOG_MESSAGE, window_log_message_params)

    def _window_show_message(self, window_show_message_params):
        """Internal handler for window show message."""
        return self._handle_notification(
            WINDOW_SHOW_MESSAGE, window_show_message_params
        )

    def _handle_notification(self, notification_name, params):
        """Internal handler for notifications."""
        fut = Future()

        def _handler():
            callback = self.get_notification_callback(notification_name)
            callback(params)
            fut.set_result(None)

        self._thread_pool.submit(_handler)
        return fut

    def _send_request(self, name, params=None, handle_response=lambda f: f.done()):
        """Sends {name} request to the LSP server."""
        fut = self._endpoint.request(name, params)
        fut.add_done_callback(handle_response)
        return fut

    def _send_notification(self, name, params=None):
        """Sends {name} notification to the LSP server."""
        self._endpoint.notify(name, params)

================
File: test/python_tests/lsp_test_client/utils.py
================
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.
"""
Utility functions for use with tests.
"""
import json
import os
import pathlib
import platform
from random import choice

from .constants import PROJECT_ROOT


def normalizecase(path: str) -> str:
    """Fixes 'file' uri or path case for easier testing in windows."""
    if platform.system() == "Windows":
        return path.lower()
    return path


def as_uri(path: str) -> str:
    """Return 'file' uri as string."""
    return normalizecase(pathlib.Path(path).as_uri())


class PythonFile:
    """Create python file on demand for testing."""

    def __init__(self, contents, root):
        self.contents = contents
        self.basename = "".join(
            choice("abcdefghijklmnopqrstuvwxyz") if i < 8 else ".py" for i in range(9)
        )
        self.fullpath = os.path.join(root, self.basename)

    def __enter__(self):
        """Creates a python file for  testing."""
        with open(self.fullpath, "w", encoding="utf8") as py_file:
            py_file.write(self.contents)
        return self

    def __exit__(self, typ, value, _tb):
        """Cleans up and deletes the python file."""
        os.unlink(self.fullpath)


def get_server_info_defaults():
    """Returns server info from package.json"""
    package_json_path = PROJECT_ROOT / "package.json"
    package_json = json.loads(package_json_path.read_text())
    return package_json["serverInfo"]


def get_initialization_options():
    """Returns initialization options from package.json"""
    package_json_path = PROJECT_ROOT / "package.json"
    package_json = json.loads(package_json_path.read_text())

    server_info = package_json["serverInfo"]
    server_id = server_info["module"]

    properties = package_json["contributes"]["configuration"]["properties"]
    setting = {}
    for prop in properties:
        name = prop[len(server_id) + 1 :]
        value = properties[prop]["default"]
        setting[name] = value

    setting["workspace"] = as_uri(str(PROJECT_ROOT))
    setting["interpreter"] = []

    return {"settings": [setting]}

================
File: test/python_tests/test_data/sample1/sample.py
================
import sys

print(x)

================
File: test/python_tests/test_data/sample1/sample.unformatted
================
import sys;print(x)

================
File: test/python_tests/__init__.py
================
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.

================
File: test/python_tests/requirements.in
================
# This file is used to generate ./src/test/python_tests/requirements.txt.
# NOTE:
# Use Python 3.8 or greater which ever is the minimum version of the python
# you plan on supporting when creating the environment or using pip-tools.
# Only run the commands below to manully upgrade packages in requirements.txt:
# 1) python -m pip install pip-tools
# 2) pip-compile --generate-hashes --upgrade ./src/test/python_tests/requirements.in
# If you are using nox commands to setup or build package you don't need to
# run the above commands manually.

# Packages needed by the testing framework.
pytest
PyHamcrest
python-jsonrpc-server

================
File: test/python_tests/requirements.txt
================
#
# This file is autogenerated by pip-compile with Python 3.8
# by the following command:
#
#    pip-compile --generate-hashes ./src/test/python_tests/requirements.in
#
colorama==0.4.6 \
    --hash=sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44 \
    --hash=sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6
    # via pytest
exceptiongroup==1.2.0 \
    --hash=sha256:4bfd3996ac73b41e9b9628b04e079f193850720ea5945fc96a08633c66912f14 \
    --hash=sha256:91f5c769735f051a4290d52edd0858999b57e5876e9f85937691bd4c9fa3ed68
    # via pytest
iniconfig==2.0.0 \
    --hash=sha256:2d91e135bf72d31a410b17c16da610a82cb55f6b0477d1a902134b24a455b8b3 \
    --hash=sha256:b6a85871a79d2e3b22d2d1b94ac2824226a63c6b741c88f7ae975f18b6778374
    # via pytest
packaging==23.2 \
    --hash=sha256:048fb0e9405036518eaaf48a55953c750c11e1a1b68e0dd1a9d62ed0c092cfc5 \
    --hash=sha256:8c491190033a9af7e1d931d0b5dacc2ef47509b34dd0de67ed209b5203fc88c7
    # via pytest
pluggy==1.3.0 \
    --hash=sha256:cf61ae8f126ac6f7c451172cf30e3e43d3ca77615509771b3a984a0730651e12 \
    --hash=sha256:d89c696a773f8bd377d18e5ecda92b7a3793cbe66c87060a6fb58c7b6e1061f7
    # via pytest
pyhamcrest==2.1.0 \
    --hash=sha256:c6acbec0923d0cb7e72c22af1926f3e7c97b8e8d69fc7498eabacaf7c975bd9c \
    --hash=sha256:f6913d2f392e30e0375b3ecbd7aee79e5d1faa25d345c8f4ff597665dcac2587
    # via -r ./src/test/python_tests/requirements.in
pytest==7.4.4 \
    --hash=sha256:2cf0005922c6ace4a3e2ec8b4080eb0d9753fdc93107415332f50ce9e7994280 \
    --hash=sha256:b090cdf5ed60bf4c45261be03239c2c1c22df034fbffe691abe93cd80cea01d8
    # via -r ./src/test/python_tests/requirements.in
python-jsonrpc-server==0.4.0 \
    --hash=sha256:62c543e541f101ec5b57dc654efc212d2c2e3ea47ff6f54b2e7dcb36ecf20595 \
    --hash=sha256:e5a908ff182e620aac07db5f57887eeb0afe33993008f57dc1b85b594cea250c
    # via -r ./src/test/python_tests/requirements.in
tomli==2.0.1 \
    --hash=sha256:939de3e7a6161af0c887ef91b7d41a53e7c5a1ca976325f429cb46ea9bc30ecc \
    --hash=sha256:de526c12914f0c550d15924c62d72abc48d6fe7364aa87328337a31007fe8a4f
    # via pytest
ujson==5.9.0 \
    --hash=sha256:07e0cfdde5fd91f54cd2d7ffb3482c8ff1bf558abf32a8b953a5d169575ae1cd \
    --hash=sha256:0b159efece9ab5c01f70b9d10bbb77241ce111a45bc8d21a44c219a2aec8ddfd \
    --hash=sha256:0c4d6adb2c7bb9eb7c71ad6f6f612e13b264942e841f8cc3314a21a289a76c4e \
    --hash=sha256:10ca3c41e80509fd9805f7c149068fa8dbee18872bbdc03d7cca928926a358d5 \
    --hash=sha256:20509a8c9f775b3a511e308bbe0b72897ba6b800767a7c90c5cca59d20d7c42c \
    --hash=sha256:25fa46e4ff0a2deecbcf7100af3a5d70090b461906f2299506485ff31d9ec437 \
    --hash=sha256:2a8ea0f55a1396708e564595aaa6696c0d8af532340f477162ff6927ecc46e21 \
    --hash=sha256:2fbb90aa5c23cb3d4b803c12aa220d26778c31b6e4b7a13a1f49971f6c7d088e \
    --hash=sha256:323279e68c195110ef85cbe5edce885219e3d4a48705448720ad925d88c9f851 \
    --hash=sha256:32bba5870c8fa2a97f4a68f6401038d3f1922e66c34280d710af00b14a3ca562 \
    --hash=sha256:3382a3ce0ccc0558b1c1668950008cece9bf463ebb17463ebf6a8bfc060dae34 \
    --hash=sha256:37ef92e42535a81bf72179d0e252c9af42a4ed966dc6be6967ebfb929a87bc60 \
    --hash=sha256:3b23bbb46334ce51ddb5dded60c662fbf7bb74a37b8f87221c5b0fec1ec6454b \
    --hash=sha256:473fb8dff1d58f49912323d7cb0859df5585cfc932e4b9c053bf8cf7f2d7c5c4 \
    --hash=sha256:4a566e465cb2fcfdf040c2447b7dd9718799d0d90134b37a20dff1e27c0e9096 \
    --hash=sha256:4e35d7885ed612feb6b3dd1b7de28e89baaba4011ecdf995e88be9ac614765e9 \
    --hash=sha256:506a45e5fcbb2d46f1a51fead991c39529fc3737c0f5d47c9b4a1d762578fc30 \
    --hash=sha256:5635b78b636a54a86fdbf6f027e461aa6c6b948363bdf8d4fbb56a42b7388320 \
    --hash=sha256:5ca35f484622fd208f55041b042d9d94f3b2c9c5add4e9af5ee9946d2d30db01 \
    --hash=sha256:60718f1720a61560618eff3b56fd517d107518d3c0160ca7a5a66ac949c6cf1c \
    --hash=sha256:63fb2e6599d96fdffdb553af0ed3f76b85fda63281063f1cb5b1141a6fcd0617 \
    --hash=sha256:6974b3a7c17bbf829e6c3bfdc5823c67922e44ff169851a755eab79a3dd31ec0 \
    --hash=sha256:6adef377ed583477cf005b58c3025051b5faa6b8cc25876e594afbb772578f21 \
    --hash=sha256:6bbd91a151a8f3358c29355a491e915eb203f607267a25e6ab10531b3b157c5e \
    --hash=sha256:6eecbd09b316cea1fd929b1e25f70382917542ab11b692cb46ec9b0a26c7427f \
    --hash=sha256:70e06849dfeb2548be48fdd3ceb53300640bc8100c379d6e19d78045e9c26120 \
    --hash=sha256:7309d063cd392811acc49b5016728a5e1b46ab9907d321ebbe1c2156bc3c0b99 \
    --hash=sha256:779a2a88c53039bebfbccca934430dabb5c62cc179e09a9c27a322023f363e0d \
    --hash=sha256:7a365eac66f5aa7a7fdf57e5066ada6226700884fc7dce2ba5483538bc16c8c5 \
    --hash=sha256:7b1c0991c4fe256f5fdb19758f7eac7f47caac29a6c57d0de16a19048eb86bad \
    --hash=sha256:7cc7e605d2aa6ae6b7321c3ae250d2e050f06082e71ab1a4200b4ae64d25863c \
    --hash=sha256:829a69d451a49c0de14a9fecb2a2d544a9b2c884c2b542adb243b683a6f15908 \
    --hash=sha256:829b824953ebad76d46e4ae709e940bb229e8999e40881338b3cc94c771b876c \
    --hash=sha256:82b5a56609f1235d72835ee109163c7041b30920d70fe7dac9176c64df87c164 \
    --hash=sha256:89cc92e73d5501b8a7f48575eeb14ad27156ad092c2e9fc7e3cf949f07e75532 \
    --hash=sha256:8ba7cac47dd65ff88571eceeff48bf30ed5eb9c67b34b88cb22869b7aa19600d \
    --hash=sha256:8fc2aa18b13d97b3c8ccecdf1a3c405f411a6e96adeee94233058c44ff92617d \
    --hash=sha256:9ac92d86ff34296f881e12aa955f7014d276895e0e4e868ba7fddebbde38e378 \
    --hash=sha256:9d302bd17989b6bd90d49bade66943c78f9e3670407dbc53ebcf61271cadc399 \
    --hash=sha256:9f21315f51e0db8ee245e33a649dd2d9dce0594522de6f278d62f15f998e050e \
    --hash=sha256:a6d3f10eb8ccba4316a6b5465b705ed70a06011c6f82418b59278fbc919bef6f \
    --hash=sha256:a807ae73c46ad5db161a7e883eec0fbe1bebc6a54890152ccc63072c4884823b \
    --hash=sha256:ab71bf27b002eaf7d047c54a68e60230fbd5cd9da60de7ca0aa87d0bccead8fa \
    --hash=sha256:b048aa93eace8571eedbd67b3766623e7f0acbf08ee291bef7d8106210432427 \
    --hash=sha256:b28407cfe315bd1b34f1ebe65d3bd735d6b36d409b334100be8cdffae2177b2f \
    --hash=sha256:b5964ea916edfe24af1f4cc68488448fbb1ec27a3ddcddc2b236da575c12c8ae \
    --hash=sha256:b68a0caab33f359b4cbbc10065c88e3758c9f73a11a65a91f024b2e7a1257106 \
    --hash=sha256:ba0823cb70866f0d6a4ad48d998dd338dce7314598721bc1b7986d054d782dfd \
    --hash=sha256:bd4ea86c2afd41429751d22a3ccd03311c067bd6aeee2d054f83f97e41e11d8f \
    --hash=sha256:bdf7fc21a03bafe4ba208dafa84ae38e04e5d36c0e1c746726edf5392e9f9f36 \
    --hash=sha256:c4eec2ddc046360d087cf35659c7ba0cbd101f32035e19047013162274e71fcf \
    --hash=sha256:cdcb02cabcb1e44381221840a7af04433c1dc3297af76fde924a50c3054c708c \
    --hash=sha256:d0fd2eba664a22447102062814bd13e63c6130540222c0aa620701dd01f4be81 \
    --hash=sha256:d581db9db9e41d8ea0b2705c90518ba623cbdc74f8d644d7eb0d107be0d85d9c \
    --hash=sha256:dc80f0f5abf33bd7099f7ac94ab1206730a3c0a2d17549911ed2cb6b7aa36d2d \
    --hash=sha256:e015122b337858dba5a3dc3533af2a8fc0410ee9e2374092f6a5b88b182e9fcc \
    --hash=sha256:e208d3bf02c6963e6ef7324dadf1d73239fb7008491fdf523208f60be6437402 \
    --hash=sha256:e2f909bc08ce01f122fd9c24bc6f9876aa087188dfaf3c4116fe6e4daf7e194f \
    --hash=sha256:f0cb4a7814940ddd6619bdce6be637a4b37a8c4760de9373bac54bb7b229698b \
    --hash=sha256:f4b3917296630a075e04d3d07601ce2a176479c23af838b6cf90a2d6b39b0d95 \
    --hash=sha256:f69f16b8f1c69da00e38dc5f2d08a86b0e781d0ad3e4cc6a13ea033a439c4844 \
    --hash=sha256:f833c529e922577226a05bc25b6a8b3eb6c4fb155b72dd88d33de99d53113124 \
    --hash=sha256:f91719c6abafe429c1a144cfe27883eace9fb1c09a9c5ef1bcb3ae80a3076a4e \
    --hash=sha256:ff741a5b4be2d08fceaab681c9d4bc89abf3c9db600ab435e20b9b6d4dfef12e \
    --hash=sha256:ffdfebd819f492e48e4f31c97cb593b9c1a8251933d8f8972e81697f00326ff1
    # via python-jsonrpc-server

================
File: test/python_tests/test_server.py
================
"""
Test for linting over LSP.
"""

from threading import Event

from hamcrest import assert_that, is_

from .lsp_test_client import constants, defaults, session, utils

TEST_FILE_PATH = constants.TEST_DATA / "sample1" / "sample.py"
TEST_FILE_URI = utils.as_uri(str(TEST_FILE_PATH))
SERVER_INFO = utils.get_server_info_defaults()
TIMEOUT = 10  # 10 seconds


def test_linting_example():
    """Test to linting on file open."""
    contents = TEST_FILE_PATH.read_text()

    actual = []
    with session.LspSession() as ls_session:
        ls_session.initialize(defaults.VSCODE_DEFAULT_INITIALIZE)

        done = Event()

        def _handler(params):
            nonlocal actual
            actual = params
            done.set()

        ls_session.set_notification_callback(session.PUBLISH_DIAGNOSTICS, _handler)

        ls_session.notify_did_open(
            {
                "textDocument": {
                    "uri": TEST_FILE_URI,
                    "languageId": "python",
                    "version": 1,
                    "text": contents,
                }
            }
        )

        # wait for some time to receive all notifications
        done.wait(TIMEOUT)

        # TODO: Add your linter specific diagnostic result here
        expected = {
            "uri": TEST_FILE_URI,
            "diagnostics": [
                {
                    # "range": {
                    #     "start": {"line": 0, "character": 0},
                    #     "end": {"line": 0, "character": 0},
                    # },
                    # "message": "Missing module docstring",
                    # "severity": 3,
                    # "code": "C0114:missing-module-docstring",
                    "source": SERVER_INFO["name"],
                },
                {
                    # "range": {
                    #     "start": {"line": 2, "character": 6},
                    #     "end": {
                    #         "line": 2,
                    #         "character": 7,
                    #     },
                    # },
                    # "message": "Undefined variable 'x'",
                    # "severity": 1,
                    # "code": "E0602:undefined-variable",
                    "source": SERVER_INFO["name"],
                },
                {
                    # "range": {
                    #     "start": {"line": 0, "character": 0},
                    #     "end": {
                    #         "line": 0,
                    #         "character": 10,
                    #     },
                    # },
                    # "message": "Unused import sys",
                    # "severity": 2,
                    # "code": "W0611:unused-import",
                    "source": SERVER_INFO["name"],
                },
            ],
        }

    assert_that(actual, is_(expected))


def test_formatting_example():
    """Test formatting a python file."""
    FORMATTED_TEST_FILE_PATH = constants.TEST_DATA / "sample1" / "sample.py"
    UNFORMATTED_TEST_FILE_PATH = constants.TEST_DATA / "sample1" / "sample.unformatted"

    contents = UNFORMATTED_TEST_FILE_PATH.read_text()
    lines = contents.splitlines(keepends=False)

    actual = []
    with utils.PythonFile(contents, UNFORMATTED_TEST_FILE_PATH.parent) as pf:
        uri = utils.as_uri(str(pf.fullpath))

        with session.LspSession() as ls_session:
            ls_session.initialize()
            ls_session.notify_did_open(
                {
                    "textDocument": {
                        "uri": uri,
                        "languageId": "python",
                        "version": 1,
                        "text": contents,
                    }
                }
            )
            actual = ls_session.text_document_formatting(
                {
                    "textDocument": {"uri": uri},
                    # `options` is not used by black
                    "options": {"tabSize": 4, "insertSpaces": True},
                }
            )

    expected = [
        {
            "range": {
                "start": {"line": 0, "character": 0},
                "end": {"line": len(lines), "character": 0},
            },
            "newText": FORMATTED_TEST_FILE_PATH.read_text(),
        }
    ]

    assert_that(actual, is_(expected))

================
File: test/suite/extension.test.ts
================
/* eslint-disable header/header */
import '@testing-library/jest-dom';
import * as vscode from 'vscode';
import { CrewPanelProvider } from '../../../webview/src/panels/crew_panel/CrewPanelProvider';

describe('Extension Test Suite', () => {
  let context: vscode.ExtensionContext;

  beforeAll(async () => {
    // Get the test extension context
    const ext = vscode.extensions.getExtension('MightyDev.tribe');
    if (!ext) {
      throw new Error('Extension not found');
    }
    await ext.activate();
    context = (global as any).testContext;
  });

  it('Extension should be present', () => {
    expect(vscode.extensions.getExtension('MightyDev.tribe')).toBeTruthy();
  });

  it('Should activate extension', async () => {
    const ext = vscode.extensions.getExtension('MightyDev.tribe');
    await ext?.activate();
    expect(ext?.isActive).toBeTruthy();
  });

  it('Should register commands', async () => {
    const commands = await vscode.commands.getCommands();
    expect(commands).toContain('tribe.showCrewPanel');
    expect(commands).toContain('tribe.generateFlow');
    expect(commands).toContain('tribe.executeFlow');
  });

  it('Should create webview panel', async () => {
    const provider = new CrewPanelProvider(context.extensionUri, context);
    expect(provider).toBeTruthy();
  });

  it('Should handle flow generation', async () => {
    const result = await vscode.commands.executeCommand('tribe.generateFlow', {
      prompt: 'Create a new React component'
    });
    expect(result).toBeTruthy();
  });

  it('Should handle flow execution', async () => {
    const result = await vscode.commands.executeCommand('tribe.executeFlow', {
      flowId: 'test-flow',
      parameters: {}
    });
    expect(result).toBeTruthy();
  });
});

================
File: test/diffManager.test.ts
================
// This test file is currently disabled due to TypeScript errors
// TODO: Fix the TypeScript errors and re-enable this test file

import * as assert from 'assert';
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { StorageService } from '../services/storageService';
import { FileChange } from '../models/types';
import * as mocha from 'mocha';

const { suite, test, suiteSetup, suiteTeardown } = mocha;

// Disabled test suite
/*
suite('Diff Manager Test Suite', () => {
	let storageService: StorageService;
	let testWorkspaceFolder: string;

	suiteSetup(async () => {
		// Get the extension context
		const extension = vscode.extensions.getExtension('tribe');
		if (!extension) {
			throw new Error('Tribe extension not found');
		}

		// Initialize the storage service
		storageService = new StorageService();

		// Create a test workspace folder
		testWorkspaceFolder = path.join(__dirname, '..', '..', 'test-workspace');
		if (!fs.existsSync(testWorkspaceFolder)) {
			fs.mkdirSync(testWorkspaceFolder, { recursive: true });
		}
	});

	suiteTeardown(() => {
		// Clean up the test workspace folder
		if (fs.existsSync(testWorkspaceFolder)) {
			fs.rmSync(testWorkspaceFolder, { recursive: true, force: true });
		}
	});

	test('Create and retrieve change group', async () => {
		// Create a test change group
		const changeGroup: ChangeGroup = {
			id: 'test-group-1',
			title: 'Test Change Group',
			description: 'A test change group for unit testing',
			agentId: 'test-agent',
			agentName: 'Test Agent',
			timestamp: new Date().toISOString(),
			files: {
				modify: [
					{
						path: 'test-file.ts',
						content: 'console.log("Modified file");',
						originalContent: 'console.log("Original file");',
						explanation: 'Modified the console log message',
					},
				],
				create: [
					{
						path: 'new-file.ts',
						content: 'console.log("New file");',
						explanation: 'Created a new file with a console log',
					},
				],
				delete: ['delete-file.ts'],
			},
		};

		// Save the change group
		await storageService.saveChangeGroup(changeGroup);

		// Retrieve the change groups
		const changeGroups = await storageService.getChangeGroups();

		// Verify the change group was saved correctly
		assert.strictEqual(changeGroups.length, 1);
		assert.strictEqual(changeGroups[0].id, 'test-group-1');
		assert.strictEqual(changeGroups[0].title, 'Test Change Group');
		assert.strictEqual(changeGroups[0].files.modify.length, 1);
		assert.strictEqual(changeGroups[0].files.create.length, 1);
		assert.strictEqual(changeGroups[0].files.delete.length, 1);
	});

	test('Delete change group', async () => {
		// Delete the change group
		await storageService.deleteChangeGroup('test-group-1');

		// Verify the change group was deleted
		const changeGroups = await storageService.getChangeGroups();
		assert.strictEqual(changeGroups.length, 0);
	});

	test('Create and retrieve checkpoint', async () => {
		// Create a test snapshot
		const snapshot = {
			'file1.ts': 'console.log("File 1");',
			'file2.ts': 'console.log("File 2");',
		};

		// Create a test checkpoint
		const checkpoint = {
			id: 'test-checkpoint-1',
			timestamp: new Date().toISOString(),
			description: 'Test Checkpoint',
			changes: {
				modified: 1,
				created: 1,
				deleted: 0,
			},
			snapshotPath: '', // This will be set by saveCheckpoint
		};

		// Save the checkpoint
		await storageService.saveCheckpoint(checkpoint, snapshot);

		// Retrieve the checkpoints
		const checkpoints = await storageService.getCheckpoints();

		// Verify the checkpoint was saved correctly
		assert.strictEqual(checkpoints.length, 1);
		assert.strictEqual(checkpoints[0].id, 'test-checkpoint-1');
		assert.strictEqual(checkpoints[0].description, 'Test Checkpoint');

		// Retrieve the snapshot
		const retrievedSnapshot = await storageService.getCheckpointSnapshot('test-checkpoint-1');

		// Verify the snapshot was saved correctly
		assert.strictEqual(Object.keys(retrievedSnapshot).length, 2);
		assert.strictEqual(retrievedSnapshot['file1.ts'], 'console.log("File 1");');
		assert.strictEqual(retrievedSnapshot['file2.ts'], 'console.log("File 2");');
	});

	test('Delete checkpoint', async () => {
		// Delete the checkpoint
		await storageService.deleteCheckpoint('test-checkpoint-1');

		// Verify the checkpoint was deleted
		const checkpoints = await storageService.getCheckpoints();
		assert.strictEqual(checkpoints.length, 0);
	});

	test('Calculate diff between snapshots', () => {
		// Create two test snapshots
		const oldSnapshot = {
			'file1.ts': 'console.log("File 1");',
			'file2.ts': 'console.log("File 2");',
			'file3.ts': 'console.log("File 3");',
		};

		const newSnapshot = {
			'file1.ts': 'console.log("Modified File 1");',
			'file2.ts': 'console.log("File 2");',
			'file4.ts': 'console.log("File 4");',
		};

		// Calculate the diff
		const diff = storageService.calculateDiff(oldSnapshot, newSnapshot);

		// Verify the diff was calculated correctly
		assert.strictEqual(diff.modified.length, 1);
		assert.strictEqual(diff.created.length, 1);
		assert.strictEqual(diff.deleted.length, 1);
		assert.strictEqual(diff.modified[0], 'file1.ts');
		assert.strictEqual(diff.created[0], 'file4.ts');
		assert.strictEqual(diff.deleted[0], 'file3.ts');
	});

	test('Create and retrieve annotation', async () => {
		// Create a test annotation
		const annotation = {
			id: 'test-annotation-1',
			content: 'This is a test annotation',
			author: {
				id: 'test-user',
				name: 'Test User',
				type: 'human' as const,
			},
			timestamp: new Date().toISOString(),
			filePath: 'test-file.ts',
			lineStart: 1,
			lineEnd: 2,
			codeSnippet: 'console.log("Test");',
			replies: [],
		};

		// Save the annotation
		await storageService.saveAnnotation(annotation);

		// Retrieve the annotations
		const annotations = await storageService.getAnnotations();

		// Verify the annotation was saved correctly
		assert.strictEqual(annotations.length, 1);
		assert.strictEqual(annotations[0].id, 'test-annotation-1');
		assert.strictEqual(annotations[0].content, 'This is a test annotation');
		assert.strictEqual(annotations[0].author.name, 'Test User');
	});

	test('Add reply to annotation', async () => {
		// Create a test reply
		const reply = {
			id: 'test-reply-1',
			content: 'This is a test reply',
			author: {
				id: 'test-agent',
				name: 'Test Agent',
				type: 'agent' as const,
			},
			timestamp: new Date().toISOString(),
			replies: [],
		};

		// Add the reply to the annotation
		await storageService.addReplyToAnnotation('test-annotation-1', reply);

		// Retrieve the annotations
		const annotations = await storageService.getAnnotations();

		// Verify the reply was added correctly
		assert.strictEqual(annotations[0].replies.length, 1);
		assert.strictEqual(annotations[0].replies[0].id, 'test-reply-1');
		assert.strictEqual(annotations[0].replies[0].content, 'This is a test reply');
		assert.strictEqual(annotations[0].replies[0].author.name, 'Test Agent');
	});

	test('Delete annotation', async () => {
		// Delete the annotation
		await storageService.deleteAnnotation('test-annotation-1');

		// Verify the annotation was deleted
		const annotations = await storageService.getAnnotations();
		assert.strictEqual(annotations.length, 0);
	});
});
*/

================
File: themes/default.json
================
{
  "name": "Tribe Dark",
  "colors": {
    "editor.background": "#1a1a1a",
    "editor.foreground": "#d4d4d4"
  }
}

================
File: commands.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { errorWrapper, ErrorSeverity } from './errorHandling';
import { StorageService } from './storage';
import { DiffUtils } from './diffUtils';

/**
 * Register all commands for the extension
 * @param context Extension context
 */
export function registerCommands(context: vscode.ExtensionContext) {
	// Initialize the storage service
	const storageService = StorageService.getInstance(context);

	// Register diff and code management commands
	const commands = [
		vscode.commands.registerCommand(
			'tribe.applyChanges',
			errorWrapper(
				async (payload: {
					filesToModify: Array<{ path: string; content: string }>;
					filesToCreate: Array<{ path: string; content: string }>;
					filesToDelete: string[];
				}): Promise<boolean> => {
					console.log('Applying changes:', payload);

					try {
						// Process file modifications
						if (payload.filesToModify && payload.filesToModify.length > 0) {
							for (const file of payload.filesToModify) {
								// Get the original content if the file exists
								const originalContent = DiffUtils.getFileContent(file.path) || '';

								// Generate a FileChange object with hunks
								const fileChange = DiffUtils.generateFileChange(
									file.path,
									originalContent,
									file.content,
								);

								// Apply the file change
								if (!DiffUtils.applyFileChange(fileChange)) {
									console.error(`Failed to apply changes to file: ${file.path}`);
									return false;
								}

								console.log(`Modified file: ${file.path}`);
							}
						}

						// Process file creations
						if (payload.filesToCreate && payload.filesToCreate.length > 0) {
							for (const file of payload.filesToCreate) {
								// Generate a FileChange object
								const fileChange = {
									path: file.path,
									content: file.content,
								};

								// Apply the file change
								if (!DiffUtils.applyFileChange(fileChange)) {
									console.error(`Failed to create file: ${file.path}`);
									return false;
								}

								console.log(`Created file: ${file.path}`);
							}
						}

						// Process file deletions
						if (payload.filesToDelete && payload.filesToDelete.length > 0) {
							for (const filePath of payload.filesToDelete) {
								// Delete the file
								if (!DiffUtils.deleteFile(filePath)) {
									console.warn(`File not found for deletion or deletion failed: ${filePath}`);
								} else {
									console.log(`Deleted file: ${filePath}`);
								}
							}
						}

						return true;
					} catch (error) {
						console.error('Error applying changes:', error);
						throw error;
					}
				},
				'APPLY_CHANGES',
				'Apply code changes to workspace files',
			),
		),

		vscode.commands.registerCommand(
			'tribe.acceptChangeGroup',
			errorWrapper(
				async (groupId: string): Promise<boolean> => {
					console.log('Accepting change group:', groupId);

					// Get the change group from storage
					const groups = await storageService.getChangeGroups();
					const group = groups.find((g) => g.id === groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return false;
					}

					// Apply all changes in the group
					const payload = {
						filesToModify: group.files.modify || [],
						filesToCreate: group.files.create || [],
						filesToDelete: group.files.delete || [],
					};

					const result = await vscode.commands.executeCommand('tribe.applyChanges', payload);

					// If successful, remove the group from storage
					if (result) {
						await storageService.deleteChangeGroup(groupId);
					}

					return !!result;
				},
				'ACCEPT_CHANGE_GROUP',
				'Accept all changes in a change group',
			),
		),

		vscode.commands.registerCommand(
			'tribe.rejectChangeGroup',
			errorWrapper(
				async (groupId: string): Promise<boolean> => {
					console.log('Rejecting change group:', groupId);

					// Remove the group from storage
					await storageService.deleteChangeGroup(groupId);
					return true;
				},
				'REJECT_CHANGE_GROUP',
				'Reject all changes in a change group',
			),
		),

		vscode.commands.registerCommand(
			'tribe.acceptFile',
			errorWrapper(
				async (
					groupId: string,
					filePath: string,
					fileType: 'modify' | 'create' | 'delete',
				): Promise<boolean> => {
					console.log(`Accepting file: ${filePath} (${fileType}) from group: ${groupId}`);

					// Get the change group from storage
					const groups = await storageService.getChangeGroups();
					const group = groups.find((g) => g.id === groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return false;
					}

					// Find the file in the appropriate list
					let fileToApply;
					let result = false;

					if (fileType === 'modify') {
						fileToApply = group.files.modify.find((f) => f.path === filePath);
						if (fileToApply) {
							result = await vscode.commands.executeCommand('tribe.applyChanges', {
								filesToModify: [fileToApply],
								filesToCreate: [],
								filesToDelete: [],
							});

							// If successful, remove the file from the group
							if (result) {
								group.files.modify = group.files.modify.filter((f) => f.path !== filePath);
							}
						}
					} else if (fileType === 'create') {
						fileToApply = group.files.create.find((f) => f.path === filePath);
						if (fileToApply) {
							result = await vscode.commands.executeCommand('tribe.applyChanges', {
								filesToModify: [],
								filesToCreate: [fileToApply],
								filesToDelete: [],
							});

							// If successful, remove the file from the group
							if (result) {
								group.files.create = group.files.create.filter((f) => f.path !== filePath);
							}
						}
					} else if (fileType === 'delete') {
						if (group.files.delete.includes(filePath)) {
							result = await vscode.commands.executeCommand('tribe.applyChanges', {
								filesToModify: [],
								filesToCreate: [],
								filesToDelete: [filePath],
							});

							// If successful, remove the file from the group
							if (result) {
								group.files.delete = group.files.delete.filter((p) => p !== filePath);
							}
						}
					}

					// If the group is now empty, remove it from storage
					if (
						group.files.modify.length === 0 &&
						group.files.create.length === 0 &&
						group.files.delete.length === 0
					) {
						await storageService.deleteChangeGroup(groupId);
					} else {
						// Otherwise, update the group in storage
						await storageService.saveChangeGroup(group);
					}

					return result;
				},
				'ACCEPT_FILE',
				'Accept changes for a specific file',
			),
		),

		vscode.commands.registerCommand(
			'tribe.rejectFile',
			errorWrapper(
				async (
					groupId: string,
					filePath: string,
					fileType: 'modify' | 'create' | 'delete',
				): Promise<boolean> => {
					console.log(`Rejecting file: ${filePath} (${fileType}) from group: ${groupId}`);

					// Get the change group from storage
					const groups = await storageService.getChangeGroups();
					const group = groups.find((g) => g.id === groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return false;
					}

					// Remove the file from the appropriate list
					if (fileType === 'modify') {
						group.files.modify = group.files.modify.filter((f) => f.path !== filePath);
					} else if (fileType === 'create') {
						group.files.create = group.files.create.filter((f) => f.path !== filePath);
					} else if (fileType === 'delete') {
						group.files.delete = group.files.delete.filter((p) => p !== filePath);
					}

					// If the group is now empty, remove it from storage
					if (
						group.files.modify.length === 0 &&
						group.files.create.length === 0 &&
						group.files.delete.length === 0
					) {
						await storageService.deleteChangeGroup(groupId);
					} else {
						// Otherwise, update the group in storage
						await storageService.saveChangeGroup(group);
					}

					return true;
				},
				'REJECT_FILE',
				'Reject changes for a specific file',
			),
		),

		vscode.commands.registerCommand(
			'tribe.modifyChange',
			errorWrapper(
				async (groupId: string, filePath: string, newContent: string): Promise<boolean> => {
					console.log(`Modifying change: ${filePath} in group: ${groupId}`);

					// Get the change group from storage
					const groups = await storageService.getChangeGroups();
					const group = groups.find((g) => g.id === groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return false;
					}

					// Find the file in the appropriate list and update its content
					let fileUpdated = false;

					// Check in modify list
					const modifyIndex = group.files.modify.findIndex((f) => f.path === filePath);
					if (modifyIndex >= 0) {
						group.files.modify[modifyIndex].content = newContent;
						fileUpdated = true;
					}

					// Check in create list
					const createIndex = group.files.create.findIndex((f) => f.path === filePath);
					if (createIndex >= 0) {
						group.files.create[createIndex].content = newContent;
						fileUpdated = true;
					}

					// If the file was updated, save the group to storage
					if (fileUpdated) {
						await storageService.saveChangeGroup(group);
					}

					return fileUpdated;
				},
				'MODIFY_CHANGE',
				'Modify content of a pending change',
			),
		),

		vscode.commands.registerCommand(
			'tribe.requestExplanation',
			errorWrapper(
				async (groupId: string, filePath: string): Promise<string> => {
					console.log(`Requesting explanation for: ${filePath} in group: ${groupId}`);

					// Get the change group from storage
					const groups = await storageService.getChangeGroups();
					const group = groups.find((g) => g.id === groupId);

					if (!group) {
						console.warn(`Change group not found: ${groupId}`);
						return "Couldn't find the change group to explain.";
					}

					// Find the file in the appropriate list
					let fileToExplain;
					let fileType: 'modify' | 'create' | 'delete' = 'modify';

					// Check in modify list
					fileToExplain = group.files.modify.find((f) => f.path === filePath);
					if (fileToExplain) {
						fileType = 'modify';
					} else {
						// Check in create list
						fileToExplain = group.files.create.find((f) => f.path === filePath);
						if (fileToExplain) {
							fileType = 'create';
						} else {
							// Check in delete list
							if (group.files.delete.includes(filePath)) {
								fileType = 'delete';
							}
						}
					}

					// If the file already has an explanation, return it
					if (fileToExplain && fileToExplain.explanation) {
						return fileToExplain.explanation;
					}

					// Otherwise, generate an explanation
					let explanation = '';
					if (fileType === 'modify') {
						explanation = `This change to ${filePath} implements the requested functionality by:
                    
1. Adding necessary imports and dependencies
2. Implementing the core logic for the feature
3. Ensuring proper error handling and edge cases
4. Optimizing performance where possible
5. Adding appropriate documentation

The key changes include updating function signatures, adding error handling, and improving the overall code structure.`;
					} else if (fileType === 'create') {
						explanation = `This new file ${filePath} is created to:
                    
1. Implement a new feature or component
2. Provide utility functions for the application
3. Enhance the overall architecture
4. Support the existing codebase with additional functionality
5. Improve maintainability and code organization

The file contains all necessary imports, proper error handling, and comprehensive documentation.`;
					} else if (fileType === 'delete') {
						explanation = `The file ${filePath} is being deleted because:
                    
1. Its functionality has been deprecated
2. It has been replaced by a more efficient implementation
3. It's no longer needed in the current architecture
4. Its functionality has been merged into other files
5. It contained outdated or redundant code`;
					}

					// If we found a file to explain, update its explanation
					if (fileToExplain) {
						fileToExplain.explanation = explanation;
						await storageService.saveChangeGroup(group);
					}

					return explanation;
				},
				'REQUEST_EXPLANATION',
				'Request explanation for a specific file change',
			),
		),

		vscode.commands.registerCommand(
			'tribe.getPendingChanges',
			errorWrapper(
				async (): Promise<any[]> => {
					// Get all change groups from storage
					return storageService.getChangeGroups();
				},
				'GET_PENDING_CHANGES',
				'Get all pending changes',
			),
		),

		vscode.commands.registerCommand(
			'tribe.viewDiff',
			errorWrapper(
				async (originalContent: string, newContent: string, title: string): Promise<void> => {
					// Use the DiffUtils class to show the diff
					await DiffUtils.showDiff(originalContent, newContent, title);
				},
				'VIEW_DIFF',
				'View diff between original and new content',
			),
		),

		vscode.commands.registerCommand(
			'tribe.createCheckpoint',
			errorWrapper(
				async (description: string): Promise<any> => {
					console.log(`Creating checkpoint: ${description}`);

					// Create a checkpoint ID
					const checkpointId = `checkpoint-${Date.now()}`;

					// Create a snapshot of the current workspace
					const snapshot = await storageService.createWorkspaceSnapshot();

					// Create the checkpoint object
					const checkpoint = {
						id: checkpointId,
						timestamp: new Date().toISOString(),
						description,
						changes: {
							modified: 0,
							created: 0,
							deleted: 0,
						},
						snapshotPath: '', // This will be set by saveCheckpoint
					};

					// Save the checkpoint to storage
					await storageService.saveCheckpoint(checkpoint, snapshot);

					return checkpoint;
				},
				'CREATE_CHECKPOINT',
				'Create a checkpoint of the current workspace state',
			),
		),

		vscode.commands.registerCommand(
			'tribe.getCheckpoints',
			errorWrapper(
				async (): Promise<any[]> => {
					// Get all checkpoints from storage
					return storageService.getCheckpoints();
				},
				'GET_CHECKPOINTS',
				'Get all checkpoints',
			),
		),

		vscode.commands.registerCommand(
			'tribe.restoreCheckpoint',
			errorWrapper(
				async (checkpointId: string): Promise<boolean> => {
					console.log(`Restoring checkpoint: ${checkpointId}`);

					try {
						// Get the checkpoint snapshot
						const snapshot = await storageService.getCheckpointSnapshot(checkpointId);

						// Restore the workspace from the snapshot
						await storageService.restoreWorkspaceFromSnapshot(snapshot);

						return true;
					} catch (error) {
						console.error(`Error restoring checkpoint: ${error}`);
						return false;
					}
				},
				'RESTORE_CHECKPOINT',
				'Restore workspace to a checkpoint',
			),
		),

		vscode.commands.registerCommand(
			'tribe.deleteCheckpoint',
			errorWrapper(
				async (checkpointId: string): Promise<boolean> => {
					console.log(`Deleting checkpoint: ${checkpointId}`);

					// Delete the checkpoint from storage
					await storageService.deleteCheckpoint(checkpointId);
					return true;
				},
				'DELETE_CHECKPOINT',
				'Delete a checkpoint',
			),
		),

		vscode.commands.registerCommand(
			'tribe.viewCheckpointDiff',
			errorWrapper(
				async (checkpointId: string): Promise<void> => {
					console.log(`Viewing diff for checkpoint: ${checkpointId}`);

					try {
						// Get the checkpoint snapshot
						const checkpointSnapshot = await storageService.getCheckpointSnapshot(checkpointId);

						// Create a snapshot of the current workspace
						const currentSnapshot = await storageService.createWorkspaceSnapshot();

						// Calculate the diff between the two snapshots
						const diff = storageService.calculateDiff(checkpointSnapshot, currentSnapshot);

						// Show a summary of the diff
						const message = `Changes since checkpoint:
- Modified: ${diff.modified.length} files
- Created: ${diff.created.length} files
- Deleted: ${diff.deleted.length} files`;

						vscode.window.showInformationMessage(message);

						// If there are modified files, show the first one
						if (diff.modified.length > 0) {
							const filePath = diff.modified[0];
							const originalContent = checkpointSnapshot[filePath] || '';
							const newContent = currentSnapshot[filePath] || '';

							// Use DiffUtils to show the diff
							await DiffUtils.showDiff(
								originalContent,
								newContent,
								`Diff for ${filePath} (Checkpoint vs Current)`,
							);
						}
					} catch (error) {
						console.error(`Error viewing checkpoint diff: ${error}`);
						vscode.window.showErrorMessage(`Failed to view checkpoint diff: ${error}`);
					}
				},
				'VIEW_CHECKPOINT_DIFF',
				'View diff between checkpoint and current state',
			),
		),

		vscode.commands.registerCommand(
			'tribe.getAnnotations',
			errorWrapper(
				async (): Promise<any[]> => {
					// Get all annotations from storage
					return storageService.getAnnotations();
				},
				'GET_ANNOTATIONS',
				'Get all annotations',
			),
		),

		vscode.commands.registerCommand(
			'tribe.addAnnotation',
			errorWrapper(
				async (annotation: any): Promise<any> => {
					console.log(`Adding annotation: ${JSON.stringify(annotation)}`);

					// Create an annotation ID if not provided
					if (!annotation.id) {
						annotation.id = `annotation-${Date.now()}`;
					}

					// Set timestamp if not provided
					if (!annotation.timestamp) {
						annotation.timestamp = new Date().toISOString();
					}

					// Initialize replies if not provided
					if (!annotation.replies) {
						annotation.replies = [];
					}

					// Save the annotation to storage
					await storageService.saveAnnotation(annotation);

					return annotation;
				},
				'ADD_ANNOTATION',
				'Add an annotation',
			),
		),

		vscode.commands.registerCommand(
			'tribe.editAnnotation',
			errorWrapper(
				async (id: string, content: string): Promise<boolean> => {
					console.log(`Editing annotation: ${id} with content: ${content}`);

					// Get all annotations from storage
					const annotations = await storageService.getAnnotations();

					// Helper function to recursively find and update the annotation
					const updateAnnotation = (items: any[]): boolean => {
						for (const item of items) {
							if (item.id === id) {
								item.content = content;
								return true;
							}
							if (item.replies && item.replies.length > 0) {
								if (updateAnnotation(item.replies)) {
									return true;
								}
							}
						}
						return false;
					};

					// Update the annotation
					if (updateAnnotation(annotations)) {
						// Save the updated annotations to storage
						await storageService.getAnnotations().then(async () => {
							for (const annotation of annotations) {
								await storageService.saveAnnotation(annotation);
							}
						});
						return true;
					}

					return false;
				},
				'EDIT_ANNOTATION',
				'Edit an annotation',
			),
		),

		vscode.commands.registerCommand(
			'tribe.deleteAnnotation',
			errorWrapper(
				async (id: string): Promise<boolean> => {
					console.log(`Deleting annotation: ${id}`);

					// Delete the annotation from storage
					await storageService.deleteAnnotation(id);
					return true;
				},
				'DELETE_ANNOTATION',
				'Delete an annotation',
			),
		),

		vscode.commands.registerCommand(
			'tribe.replyToAnnotation',
			errorWrapper(
				async (parentId: string, reply: any): Promise<any> => {
					console.log(`Replying to annotation: ${parentId} with: ${JSON.stringify(reply)}`);

					// Create a reply ID if not provided
					if (!reply.id) {
						reply.id = `reply-${Date.now()}`;
					}

					// Set timestamp if not provided
					if (!reply.timestamp) {
						reply.timestamp = new Date().toISOString();
					}

					// Initialize replies if not provided
					if (!reply.replies) {
						reply.replies = [];
					}

					// Add the reply to the parent annotation
					await storageService.addReplyToAnnotation(parentId, reply);

					return reply;
				},
				'REPLY_TO_ANNOTATION',
				'Reply to an annotation',
			),
		),

		vscode.commands.registerCommand(
			'tribe.selectImplementation',
			errorWrapper(
				async (implementationId: string): Promise<boolean> => {
					console.log(`Selecting implementation: ${implementationId}`);

					// Get the implementation from storage
					const implementations = await storageService.getImplementations();
					const implementation = implementations.find((i) => i.id === implementationId);

					if (!implementation) {
						console.warn(`Implementation not found: ${implementationId}`);
						return false;
					}

					// Convert the implementation to a change group
					const changeGroup = {
						id: `group-${Date.now()}`,
						title: implementation.title,
						description: implementation.description,
						agentId: 'system',
						agentName: 'System',
						timestamp: new Date().toISOString(),
						files: implementation.files,
					};

					// Save the change group to storage
					await storageService.saveChangeGroup(changeGroup);

					// Delete the implementation from storage
					await storageService.deleteImplementation(implementationId);

					return true;
				},
				'SELECT_IMPLEMENTATION',
				'Select an alternative implementation',
			),
		),

		vscode.commands.registerCommand(
			'tribe.generateHunks',
			errorWrapper(
				async (filePath: string, originalContent: string, modifiedContent: string): Promise<any[]> => {
					console.log(`Generating hunks for file: ${filePath}`);

					// Use DiffUtils to generate hunks
					return DiffUtils.generateHunks(originalContent, modifiedContent);
				},
				'GENERATE_HUNKS',
				'Generate hunks for a file change',
			),
		),

		vscode.commands.registerCommand(
			'tribe.createChangeGroup',
			errorWrapper(
				async (payload: {
					title: string;
					description: string;
					agentId: string;
					agentName: string;
					filesToModify: Array<{ path: string; content: string }>;
					filesToCreate: Array<{ path: string; content: string }>;
					filesToDelete: string[];
				}): Promise<string> => {
					console.log(`Creating change group: ${payload.title}`);

					// Generate a unique ID for the change group
					const groupId = `group-${Date.now()}`;

					// Create file changes with hunks for modified files
					const modifyChanges = await Promise.all(
						payload.filesToModify.map(async (file) => {
							// Get the original content if the file exists
							const originalContent = DiffUtils.getFileContent(file.path) || '';

							// Generate a FileChange object with hunks
							return DiffUtils.generateFileChange(file.path, originalContent, file.content);
						}),
					);

					// Create file changes for new files
					const createChanges = payload.filesToCreate.map((file) => ({
						path: file.path,
						content: file.content,
						explanation: `Created new file: ${file.path}`,
					}));

					// Create the change group
					const changeGroup = {
						id: groupId,
						title: payload.title,
						description: payload.description,
						agentId: payload.agentId,
						agentName: payload.agentName,
						timestamp: new Date().toISOString(),
						files: {
							modify: modifyChanges,
							create: createChanges,
							delete: payload.filesToDelete,
						},
					};

					// Save the change group
					await storageService.saveChangeGroup(changeGroup);

					return groupId;
				},
				'CREATE_CHANGE_GROUP',
				'Create a change group from a set of changes',
			),
		),

		vscode.commands.registerCommand(
			'tribe.getWorkspaceSnapshot',
			errorWrapper(
				async (): Promise<Record<string, string>> => {
					console.log('Getting workspace snapshot');

					// Use the storage service to create a workspace snapshot
					return storageService.createWorkspaceSnapshot();
				},
				'GET_WORKSPACE_SNAPSHOT',
				'Get a snapshot of the current workspace',
			),
		),

		// Enhanced diff algorithm commands
		vscode.commands.registerCommand(
			'tribe.calculateDetailedDiff',
			errorWrapper(
				async (payload: { oldContent: string; newContent: string; filePath: string }): Promise<any> => {
					console.log('Calculating detailed diff for:', payload.filePath);

					try {
						// Generate a FileChange object with hunks using Myers diff algorithm
						const fileChange = DiffUtils.generateFileChange(
							payload.filePath,
							payload.oldContent,
							payload.newContent,
						);

						return {
							fileChange,
							success: true,
						};
					} catch (error) {
						console.error('Error calculating detailed diff:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'Calculate detailed diff',
				ErrorSeverity.ERROR,
			),
		),

		// Conflict resolution commands
		vscode.commands.registerCommand(
			'tribe.detectConflicts',
			errorWrapper(
				async (payload: {
					changes: Array<{
						agentId: string;
						agentName: string;
						files: {
							modify: Array<{ path: string; content: string; originalContent?: string }>;
							create: Array<{ path: string; content: string }>;
							delete: string[];
						};
					}>;
				}): Promise<any> => {
					console.log('Detecting conflicts in changes from multiple agents');

					try {
						const conflicts: Array<{
							id: string;
							type: 'merge' | 'dependency' | 'logic' | 'other';
							description: string;
							status: 'pending';
							files: string[];
							conflictingChanges: Record<string, any[]>;
						}> = [];

						// Group changes by file path
						const fileChanges: Record<
							string,
							Array<{
								agentId: string;
								agentName: string;
								content: string;
								originalContent?: string;
							}>
						> = {};

						// Collect all file modifications
						for (const change of payload.changes) {
							for (const file of change.files.modify) {
								if (!fileChanges[file.path]) {
									fileChanges[file.path] = [];
								}

								fileChanges[file.path].push({
									agentId: change.agentId,
									agentName: change.agentName,
									content: file.content,
									originalContent: file.originalContent,
								});
							}
						}

						// Detect conflicts in file modifications
						for (const [filePath, changes] of Object.entries(fileChanges)) {
							if (changes.length > 1) {
								// Check if the changes are identical
								const firstContent = changes[0].content;
								const hasConflict = changes.some((change) => change.content !== firstContent);

								if (hasConflict) {
									// Create a conflict
									const conflictId = `conflict-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
									const conflictingChanges: Record<string, any[]> = {};

									for (const change of changes) {
										if (!conflictingChanges[change.agentId]) {
											conflictingChanges[change.agentId] = [];
										}

										conflictingChanges[change.agentId].push({
											path: filePath,
											content: change.content,
											originalContent: change.originalContent,
											timestamp: new Date().toISOString(),
										});
									}

									conflicts.push({
										id: conflictId,
										type: 'merge',
										description: `Multiple agents modified ${filePath}`,
										status: 'pending',
										files: [filePath],
										conflictingChanges,
									});

									// Save the conflict to storage
									await storageService.saveConflict({
										id: conflictId,
										type: 'merge',
										description: `Multiple agents modified ${filePath}`,
										status: 'pending',
										files: [filePath],
										conflictingChanges,
									});
								}
							}
						}

						return {
							conflicts,
							success: true,
						};
					} catch (error) {
						console.error('Error detecting conflicts:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'Detect conflicts',
				ErrorSeverity.ERROR,
			),
		),

		vscode.commands.registerCommand(
			'tribe.resolveConflict',
			errorWrapper(
				async (payload: {
					conflictId: string;
					resolution: 'auto' | 'manual';
					manualResolution?: {
						path: string;
						content: string;
					}[];
				}): Promise<any> => {
					console.log('Resolving conflict:', payload.conflictId);

					try {
						if (payload.resolution === 'auto') {
							// Use the automatic conflict resolution
							const resolvedChanges = await storageService.resolveConflictAutomatically(
								payload.conflictId,
							);

							return {
								resolvedChanges,
								success: true,
							};
						} else if (payload.resolution === 'manual' && payload.manualResolution) {
							// Apply the manual resolution
							const conflicts = await storageService.getConflicts();
							const conflict = conflicts.find((c) => c.id === payload.conflictId);

							if (!conflict) {
								throw new Error(`Conflict not found: ${payload.conflictId}`);
							}

							// Update the conflict with the resolved changes
							conflict.resolvedChanges = payload.manualResolution.map((file) => ({
								path: file.path,
								content: file.content,
								timestamp: new Date().toISOString(),
							}));

							conflict.status = 'resolved';
							conflict.resolutionStrategy = 'manual';
							conflict.resolutionTimestamp = new Date().toISOString();

							await storageService.saveConflict(conflict);

							return {
								resolvedChanges: conflict.resolvedChanges,
								success: true,
							};
						} else {
							throw new Error('Invalid resolution strategy or missing manual resolution');
						}
					} catch (error) {
						console.error('Error resolving conflict:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'Resolve conflict',
				ErrorSeverity.ERROR,
			),
		),

		// Change history commands
		vscode.commands.registerCommand(
			'tribe.getChangeHistory',
			errorWrapper(
				async (): Promise<any> => {
					console.log('Getting change history');

					try {
						const history = await storageService.getChangeHistory();
						return {
							history,
							success: true,
						};
					} catch (error) {
						console.error('Error getting change history:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'Get change history',
				ErrorSeverity.ERROR,
			),
		),

		// Checkpoint and sub-checkpoint commands
		vscode.commands.registerCommand(
			'tribe.createCheckpoint',
			errorWrapper(
				async (payload: { description: string; changeGroups?: string[] }): Promise<any> => {
					console.log('Creating checkpoint:', payload.description);

					try {
						// Create a snapshot of the current workspace
						const snapshotData = await storageService.createWorkspaceSnapshot();

						// Create a checkpoint
						const checkpoint = {
							id: `checkpoint-${Date.now()}`,
							timestamp: new Date().toISOString(),
							description: payload.description,
							changes: {
								modified: 0,
								created: 0,
								deleted: 0,
							},
							snapshotPath: '',
							changeGroups: payload.changeGroups || [],
						};

						// Save the checkpoint
						await storageService.saveCheckpoint(checkpoint, snapshotData);

						return {
							checkpoint,
							success: true,
						};
					} catch (error) {
						console.error('Error creating checkpoint:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'Create checkpoint',
				ErrorSeverity.ERROR,
			),
		),

		vscode.commands.registerCommand(
			'tribe.createSubCheckpoint',
			errorWrapper(
				async (payload: {
					parentCheckpointId: string;
					description: string;
					changes: {
						modified: string[];
						created: string[];
						deleted: string[];
					};
				}): Promise<any> => {
					console.log('Creating sub-checkpoint for:', payload.parentCheckpointId);

					try {
						const subCheckpoint = await storageService.createSubCheckpoint(
							payload.parentCheckpointId,
							payload.description,
							payload.changes,
						);

						return {
							subCheckpoint,
							success: true,
						};
					} catch (error) {
						console.error('Error creating sub-checkpoint:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'Create sub-checkpoint',
				ErrorSeverity.ERROR,
			),
		),

		vscode.commands.registerCommand(
			'tribe.revertToSubCheckpoint',
			errorWrapper(
				async (payload: { parentCheckpointId: string; subCheckpointId: string }): Promise<any> => {
					console.log('Reverting to sub-checkpoint:', payload.subCheckpointId);

					try {
						await storageService.revertToSubCheckpoint(payload.parentCheckpointId, payload.subCheckpointId);

						return {
							success: true,
						};
					} catch (error) {
						console.error('Error reverting to sub-checkpoint:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'Revert to sub-checkpoint',
				ErrorSeverity.ERROR,
			),
		),

		// Semantic grouping commands
		vscode.commands.registerCommand(
			'tribe.groupChangesByFeature',
			errorWrapper(
				async (payload: {
					fileChanges: Array<{
						path: string;
						content: string;
						originalContent?: string;
						hunks?: Array<{
							startLine: number;
							endLine: number;
							content: string;
							originalContent?: string;
							semanticGroup?: string;
						}>;
					}>;
				}): Promise<any> => {
					console.log('Grouping changes by feature');

					try {
						const groupedChanges = storageService.groupFileChangesByFeature(payload.fileChanges);

						return {
							groupedChanges,
							success: true,
						};
					} catch (error) {
						console.error('Error grouping changes by feature:', error);
						return {
							error: error instanceof Error ? error.message : String(error),
							success: false,
						};
					}
				},
				'Group changes by feature',
				ErrorSeverity.ERROR,
			),
		),
	];

	// Register all commands
	context.subscriptions.push(...commands);
}

================
File: config.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import * as path from 'path';
import * as os from 'os';

/**
 * API endpoints for the extension
 */
export const API_ENDPOINTS = {
	AI_API: 'https://teqheaidyjmkjwkvkde65rfmo40epndv.lambda-url.eu-west-3.on.aws/',
	ANALYTICS: 'https://analytics.example.com/api',
	GENERATE_EXPLANATION: '/api/generate-explanation',
	GENERATE_IMPLEMENTATION: '/api/generate-implementation',
	RESOLVE_CONFLICT: '/api/resolve-conflict',
};

/**
 * Storage paths for the extension
 */
export const STORAGE_PATHS = {
	BASE_DIR: '.tribe',
	CHANGE_GROUPS: 'changeGroups',
	CHECKPOINTS: 'checkpoints',
	ANNOTATIONS: 'annotations',
	IMPLEMENTATIONS: 'implementations',
	CONFLICTS: 'conflicts',
	HISTORY: 'history',
};

/**
 * Command identifiers for the extension
 */
export const COMMANDS = {
	// Change management commands
	APPLY_CHANGES: 'tribe.applyChanges',
	CREATE_CHANGE_GROUP: 'tribe.createChangeGroup',
	ACCEPT_CHANGE_GROUP: 'tribe.acceptChangeGroup',
	REJECT_CHANGE_GROUP: 'tribe.rejectChangeGroup',
	ACCEPT_FILE: 'tribe.acceptFile',
	REJECT_FILE: 'tribe.rejectFile',
	MODIFY_CHANGE: 'tribe.modifyChange',
	REQUEST_EXPLANATION: 'tribe.requestExplanation',
	GET_PENDING_CHANGES: 'tribe.getPendingChanges',
	VIEW_DIFF: 'tribe.viewDiff',
	GENERATE_HUNKS: 'tribe.generateHunks',

	// Checkpoint commands
	CREATE_CHECKPOINT: 'tribe.createCheckpoint',
	GET_CHECKPOINTS: 'tribe.getCheckpoints',
	RESTORE_CHECKPOINT: 'tribe.restoreCheckpoint',
	DELETE_CHECKPOINT: 'tribe.deleteCheckpoint',
	VIEW_CHECKPOINT_DIFF: 'tribe.viewCheckpointDiff',
	CREATE_SUB_CHECKPOINT: 'tribe.createSubCheckpoint',
	REVERT_TO_SUB_CHECKPOINT: 'tribe.revertToSubCheckpoint',

	// Annotation commands
	CREATE_ANNOTATION: 'tribe.createAnnotation',
	GET_ANNOTATIONS: 'tribe.getAnnotations',
	DELETE_ANNOTATION: 'tribe.deleteAnnotation',
	RESOLVE_ANNOTATION: 'tribe.resolveAnnotation',
	ADD_REPLY: 'tribe.addReply',
	SHOW_ANNOTATIONS_IN_FILE: 'tribe.showAnnotationsInFile',

	// Implementation commands
	CREATE_IMPLEMENTATION: 'tribe.createImplementation',
	GET_IMPLEMENTATIONS: 'tribe.getImplementations',
	DELETE_IMPLEMENTATION: 'tribe.deleteImplementation',
	APPLY_IMPLEMENTATION: 'tribe.applyImplementation',
	VIEW_IMPLEMENTATION_DIFF: 'tribe.viewImplementationDiff',
	UPDATE_IMPLEMENTATION_STATUS: 'tribe.updateImplementationStatus',

	// Conflict commands
	CREATE_CONFLICT: 'tribe.createConflict',
	GET_CONFLICTS: 'tribe.getConflicts',
	DELETE_CONFLICT: 'tribe.deleteConflict',
	RESOLVE_CONFLICT: 'tribe.resolveConflict',
	RESOLVE_CONFLICT_WITH_AGENT: 'tribe.resolveConflictWithAgent',
	RESOLVE_CONFLICT_WITH_USER: 'tribe.resolveConflictWithUser',
	VIEW_CONFLICT_DIFF: 'tribe.viewConflictDiff',
	MERGE_CONFLICT_CHANGES: 'tribe.mergeConflictChanges',

	// History commands
	RECORD_HISTORY_ENTRY: 'tribe.recordHistoryEntry',
	GET_HISTORY: 'tribe.getHistory',
	CLEAR_HISTORY: 'tribe.clearHistory',
	VIEW_HISTORY_DIFF: 'tribe.viewHistoryDiff',
	REVERT_HISTORY_ENTRY: 'tribe.revertHistoryEntry',
	SHOW_HISTORY_VIEW: 'tribe.showHistoryView',

	// Workspace management
	GET_WORKSPACE_SNAPSHOT: 'tribe.getWorkspaceSnapshot',

	// Semantic grouping
	GROUP_CHANGES_BY_FEATURE: 'tribe.groupChangesByFeature',

	// UI commands
	SHOW_CREW_PANEL: 'tribe.showCrewPanel',
	RESTART_SERVER: 'tribe.restart',
};

/**
 * Storage directory names
 */
export const STORAGE_DIRS = {
	CHANGE_GROUPS: 'change_groups',
	CHECKPOINTS: 'checkpoints',
	ANNOTATIONS: 'annotations',
	IMPLEMENTATIONS: 'implementations',
	CONFLICTS: 'conflicts',
	HISTORY: 'history',
};

/**
 * Get configuration value from VS Code settings
 * @param section Configuration section
 * @param defaultValue Default value if not found
 * @returns Configuration value
 */
export function getConfiguration<T>(section: string, defaultValue: T): T {
	return vscode.workspace.getConfiguration('tribe').get<T>(section, defaultValue);
}

/**
 * Update configuration value in VS Code settings
 * @param section Configuration section
 * @param value New value
 * @param configurationTarget Target scope
 * @returns Promise that resolves when the update is complete
 */
export async function updateConfiguration<T>(
	section: string,
	value: T,
	configurationTarget: vscode.ConfigurationTarget = vscode.ConfigurationTarget.Global,
): Promise<void> {
	return vscode.workspace.getConfiguration('tribe').update(section, value, configurationTarget);
}

/**
 * Extension settings with default values
 */
export const DEFAULT_SETTINGS = {
	STORAGE_DIR: path.join(os.homedir(), '.tribe'),
	LOG_LEVEL: 'info',
	AUTO_APPLY_CHANGES: false,
	SHOW_NOTIFICATIONS: true,
	CONFLICT_RESOLUTION_STRATEGY: 'manual',
	MAX_HISTORY_ENTRIES: 100,
	CHECKPOINT_INTERVAL: 60 * 60 * 1000, // 1 hour in milliseconds
};

/**
 * Get the extension's storage directory
 * @returns Path to the storage directory
 */
export function getStorageDirectory(): string {
	return getConfiguration<string>('storageDir', DEFAULT_SETTINGS.STORAGE_DIR);
}

================
File: diffUtils.ts
================
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { FileChange } from './storage';

/**
 * Utility functions for generating and managing diffs between files
 */
export class DiffUtils {
	/**
	 * Generate hunks for a file change by comparing original and modified content using Myers diff algorithm
	 * @param originalContent The original file content
	 * @param modifiedContent The modified file content
	 * @returns An array of hunks representing the changes
	 */
	static generateHunks(
		originalContent: string,
		modifiedContent: string,
	): Array<{
		startLine: number;
		endLine: number;
		content: string;
		originalContent: string;
		semanticGroup?: string;
	}> {
		// Split the content into lines
		const originalLines = originalContent.split('\n');
		const modifiedLines = modifiedContent.split('\n');

		// Compute the diff using Myers algorithm
		const diff = this.myersDiff(originalLines, modifiedLines);

		// Convert diff to hunks
		const hunks: Array<{
			startLine: number;
			endLine: number;
			content: string;
			originalContent: string;
			semanticGroup?: string;
		}> = [];

		let currentHunk: {
			startLine: number;
			endLine: number;
			content: string[];
			originalContent: string[];
		} | null = null;

		let i = 0;
		let j = 0;

		for (const edit of diff) {
			if (edit.type === 'equal') {
				// Lines are the same, close current hunk if any
				if (currentHunk) {
					hunks.push({
						startLine: currentHunk.startLine,
						endLine: currentHunk.endLine,
						content: currentHunk.content.join('\n'),
						originalContent: currentHunk.originalContent.join('\n'),
					});
					currentHunk = null;
				}
				i += edit.count;
				j += edit.count;
			} else {
				// Lines are different, start or continue a hunk
				if (!currentHunk) {
					currentHunk = {
						startLine: i + 1, // 1-indexed
						endLine: i + 1,
						content: [],
						originalContent: [],
					};
				}

				if (edit.type === 'delete') {
					// Add original lines
					for (let k = 0; k < edit.count; k++) {
						currentHunk.originalContent.push(originalLines[i]);
						i++;
					}
					currentHunk.endLine = i + 1;
				} else if (edit.type === 'insert') {
					// Add modified lines
					for (let k = 0; k < edit.count; k++) {
						currentHunk.content.push(modifiedLines[j]);
						j++;
					}
				} else if (edit.type === 'replace') {
					// Add both original and modified lines
					for (let k = 0; k < edit.count; k++) {
						if (i < originalLines.length) {
							currentHunk.originalContent.push(originalLines[i]);
							i++;
						}
						if (j < modifiedLines.length) {
							currentHunk.content.push(modifiedLines[j]);
							j++;
						}
					}
					currentHunk.endLine = i + 1;
				}
			}
		}

		// Close final hunk if any
		if (currentHunk) {
			hunks.push({
				startLine: currentHunk.startLine,
				endLine: currentHunk.endLine,
				content: currentHunk.content.join('\n'),
				originalContent: currentHunk.originalContent.join('\n'),
			});
		}

		// Apply semantic grouping to hunks
		return this.applySemanticGrouping(hunks, originalContent, modifiedContent);
	}

	/**
	 * Implements the Myers diff algorithm to find the shortest edit script between two sequences
	 * @param a First sequence
	 * @param b Second sequence
	 * @returns Array of edit operations
	 */
	private static myersDiff(
		a: string[],
		b: string[],
	): Array<{ type: 'equal' | 'insert' | 'delete' | 'replace'; count: number }> {
		const n = a.length;
		const m = b.length;
		const max = n + m;
		const v = new Array(2 * max + 1).fill(0);
		const trace: number[][] = [];

		// Find the shortest edit script
		let d;
		for (d = 0; d <= max; d++) {
			trace.push([...v]);
			for (let k: number = -d; k <= d; k += 2) {
				let x;
				if (k === -d || (k !== d && v[max + k - 1] < v[max + k + 1])) {
					x = v[max + k + 1];
				} else {
					x = v[max + k - 1] + 1;
				}
				let y = x - k;

				while (x < n && y < m && a[x] === b[y]) {
					x++;
					y++;
				}

				v[max + k] = x;

				if (x >= n && y >= m) {
					break;
				}
			}
			if (v[max + (n - m)] >= n) {
				break;
			}
		}

		// Backtrack to find the edit script
		const edits: Array<{ type: 'equal' | 'insert' | 'delete' | 'replace'; count: number }> = [];
		let x = n;
		let y = m;

		for (let d = trace.length - 1; d >= 0 && (x > 0 || y > 0); d--) {
			const v = trace[d];
			const k = x - y;

			let prevK;
			if (k === -d || (k !== d && v[max + k - 1] < v[max + k + 1])) {
				prevK = k + 1;
			} else {
				prevK = k - 1;
			}

			const prevX = v[max + prevK];
			const prevY = prevX - prevK;

			while (x > prevX && y > prevY) {
				// Equal elements
				edits.unshift({ type: 'equal', count: 1 });
				x--;
				y--;
			}

			if (d > 0) {
				if (x === prevX) {
					// Insertion
					edits.unshift({ type: 'insert', count: 1 });
					y--;
				} else if (y === prevY) {
					// Deletion
					edits.unshift({ type: 'delete', count: 1 });
					x--;
				} else {
					// Replacement
					edits.unshift({ type: 'replace', count: 1 });
					x--;
					y--;
				}
			}
		}

		// Consolidate consecutive operations of the same type
		const consolidatedEdits: Array<{ type: 'equal' | 'insert' | 'delete' | 'replace'; count: number }> = [];
		for (const edit of edits) {
			if (consolidatedEdits.length > 0 && consolidatedEdits[consolidatedEdits.length - 1].type === edit.type) {
				consolidatedEdits[consolidatedEdits.length - 1].count += edit.count;
			} else {
				consolidatedEdits.push({ ...edit });
			}
		}

		return consolidatedEdits;
	}

	/**
	 * Apply semantic grouping to hunks based on code structure
	 * @param hunks Array of hunks to group
	 * @param originalContent Original file content
	 * @param modifiedContent Modified file content
	 * @returns Hunks with semantic grouping applied
	 */
	private static applySemanticGrouping(
		hunks: Array<{
			startLine: number;
			endLine: number;
			content: string;
			originalContent: string;
			semanticGroup?: string;
		}>,
		originalContent: string,
		modifiedContent: string,
	): Array<{
		startLine: number;
		endLine: number;
		content: string;
		originalContent: string;
		semanticGroup?: string;
	}> {
		// Identify semantic structures in the code
		const structures = this.identifyCodeStructures(originalContent, modifiedContent);

		// Apply semantic groups to hunks
		for (const hunk of hunks) {
			for (const structure of structures) {
				if (
					(hunk.startLine >= structure.startLine && hunk.startLine <= structure.endLine) ||
					(hunk.endLine >= structure.startLine && hunk.endLine <= structure.endLine)
				) {
					hunk.semanticGroup = structure.name;
					break;
				}
			}
		}

		return hunks;
	}

	/**
	 * Identify code structures in the content for semantic grouping
	 * @param originalContent Original file content
	 * @param modifiedContent Modified file content
	 * @returns Array of identified code structures
	 */
	private static identifyCodeStructures(
		originalContent: string,
		modifiedContent: string,
	): Array<{ name: string; startLine: number; endLine: number }> {
		const structures: Array<{ name: string; startLine: number; endLine: number }> = [];

		// Simple regex-based structure identification
		// Identify functions/methods
		const functionRegex =
			/\b(function|class|const|let|var|async|public|private|protected)\s+([a-zA-Z0-9_]+)\s*[({]/g;
		const lines = modifiedContent.split('\n');

		let match;
		let currentLine = 1;
		let inStructure = false;
		let structureStart = 0;
		let structureName = '';
		let braceCount = 0;

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];

			// Check for structure start
			const lineMatch = functionRegex.exec(line);
			if (lineMatch && !inStructure) {
				inStructure = true;
				structureStart = i + 1;
				structureName = `${lineMatch[1]} ${lineMatch[2]}`;
				braceCount = 0;
			}

			// Count braces to track structure boundaries
			if (inStructure) {
				for (const char of line) {
					if (char === '{') braceCount++;
					if (char === '}') braceCount--;
				}

				// Structure end
				if (braceCount === 0 && structureStart > 0) {
					structures.push({
						name: structureName,
						startLine: structureStart,
						endLine: i + 1,
					});
					inStructure = false;
					structureStart = 0;
				}
			}

			currentLine++;
		}

		return structures;
	}

	/**
	 * Generate a FileChange object with hunks for a modified file
	 * @param filePath The path to the file
	 * @param originalContent The original file content
	 * @param modifiedContent The modified file content
	 * @returns A FileChange object with hunks
	 */
	static generateFileChange(filePath: string, originalContent: string, modifiedContent: string): FileChange {
		const hunks = this.generateHunks(originalContent, modifiedContent);

		return {
			path: filePath,
			content: modifiedContent,
			originalContent,
			hunks,
		};
	}

	/**
	 * Show a diff between two files in the VS Code diff editor
	 * @param originalContent The original file content
	 * @param modifiedContent The modified file content
	 * @param title The title for the diff editor
	 */
	static async showDiff(originalContent: string, modifiedContent: string, title: string): Promise<void> {
		// Create temporary files for the diff
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			throw new Error('No workspace folder found');
		}

		const tempDir = path.join(workspaceFolder.uri.fsPath, '.tribe-temp');
		if (!fs.existsSync(tempDir)) {
			fs.mkdirSync(tempDir, { recursive: true });
		}

		const originalFile = path.join(tempDir, `original-${Date.now()}.txt`);
		const modifiedFile = path.join(tempDir, `modified-${Date.now()}.txt`);

		fs.writeFileSync(originalFile, originalContent, 'utf8');
		fs.writeFileSync(modifiedFile, modifiedContent, 'utf8');

		// Open diff view
		const originalUri = vscode.Uri.file(originalFile);
		const modifiedUri = vscode.Uri.file(modifiedFile);

		await vscode.commands.executeCommand('vscode.diff', originalUri, modifiedUri, title);
	}

	/**
	 * Get the current content of a file in the workspace
	 * @param filePath The path to the file, relative to the workspace root
	 * @returns The content of the file, or null if the file doesn't exist
	 */
	static getFileContent(filePath: string): string | null {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return null;
		}

		const fullPath = path.join(workspaceFolder.uri.fsPath, filePath);

		if (!fs.existsSync(fullPath)) {
			return null;
		}

		return fs.readFileSync(fullPath, 'utf8');
	}

	/**
	 * Apply a file change to the workspace
	 * @param fileChange The file change to apply
	 * @returns True if the change was applied successfully, false otherwise
	 */
	static applyFileChange(fileChange: FileChange): boolean {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return false;
		}

		const fullPath = path.join(workspaceFolder.uri.fsPath, fileChange.path);
		const dirPath = path.dirname(fullPath);

		try {
			// Ensure directory exists
			if (!fs.existsSync(dirPath)) {
				fs.mkdirSync(dirPath, { recursive: true });
			}

			// Write file content
			fs.writeFileSync(fullPath, fileChange.content, 'utf8');

			return true;
		} catch (error) {
			console.error(`Error applying file change: ${error}`);
			return false;
		}
	}

	/**
	 * Delete a file from the workspace
	 * @param filePath The path to the file, relative to the workspace root
	 * @returns True if the file was deleted successfully, false otherwise
	 */
	static deleteFile(filePath: string): boolean {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return false;
		}

		const fullPath = path.join(workspaceFolder.uri.fsPath, filePath);

		try {
			if (fs.existsSync(fullPath)) {
				fs.unlinkSync(fullPath);
				return true;
			}
			return false;
		} catch (error) {
			console.error(`Error deleting file: ${error}`);
			return false;
		}
	}

	/**
	 * Group related changes by feature or functionality
	 * @param changeGroups Array of change groups to analyze
	 * @returns Object mapping feature names to arrays of related file changes
	 */
	static groupChangesByFeature(changeGroups: any[]): Record<string, any[]> {
		const featureGroups: Record<string, any[]> = {};

		// Analyze change groups to identify related changes
		for (const group of changeGroups) {
			// Extract potential feature names from titles and descriptions
			const featureNames = this.extractFeatureNames(group.title, group.description);

			// If no feature names found, use a default group
			if (featureNames.length === 0) {
				if (!featureGroups['Uncategorized']) {
					featureGroups['Uncategorized'] = [];
				}
				featureGroups['Uncategorized'].push(group);
				continue;
			}

			// Add to each identified feature group
			for (const feature of featureNames) {
				if (!featureGroups[feature]) {
					featureGroups[feature] = [];
				}
				featureGroups[feature].push(group);
			}
		}

		return featureGroups;
	}

	/**
	 * Extract potential feature names from title and description
	 * @param title Change group title
	 * @param description Change group description
	 * @returns Array of potential feature names
	 */
	private static extractFeatureNames(title: string, description: string): string[] {
		const featureNames: string[] = [];

		// Common feature-related keywords
		const featureKeywords = [
			'feature',
			'functionality',
			'component',
			'module',
			'system',
			'service',
			'api',
			'endpoint',
			'interface',
			'ui',
			'ux',
		];

		// Extract potential feature names from title
		if (title) {
			for (const keyword of featureKeywords) {
				const regex = new RegExp(`(\\w+)\\s+${keyword}`, 'i');
				const match = title.match(regex);
				if (match && match[1]) {
					featureNames.push(`${match[1]} ${keyword}`);
				}
			}
		}

		// If no features found in title, try description
		if (featureNames.length === 0 && description) {
			for (const keyword of featureKeywords) {
				const regex = new RegExp(`(\\w+)\\s+${keyword}`, 'i');
				const match = description.match(regex);
				if (match && match[1]) {
					featureNames.push(`${match[1]} ${keyword}`);
				}
			}
		}

		// If still no features found, use the first part of the title as a feature name
		if (featureNames.length === 0 && title) {
			const words = title.split(' ');
			if (words.length >= 2) {
				featureNames.push(words.slice(0, 2).join(' '));
			} else if (words.length === 1) {
				featureNames.push(words[0]);
			}
		}

		return featureNames;
	}
}

================
File: errorHandling.ts
================
export enum ErrorSeverity {
	INFO = 'INFO',
	WARNING = 'WARNING',
	ERROR = 'ERROR',
	CRITICAL = 'CRITICAL',
}

export interface ExtensionError extends Error {
	severity: ErrorSeverity;
	code: string;
	details?: any;
	timestamp: string;
}

export class ExtensionErrorHandler {
	private static instance: ExtensionErrorHandler;
	private errorListeners: ((error: ExtensionError) => void)[] = [];

	private constructor() {}

	public static getInstance(): ExtensionErrorHandler {
		if (!ExtensionErrorHandler.instance) {
			ExtensionErrorHandler.instance = new ExtensionErrorHandler();
		}
		return ExtensionErrorHandler.instance;
	}

	public addErrorListener(listener: (error: ExtensionError) => void): void {
		this.errorListeners.push(listener);
	}

	public handleError(error: Error | ExtensionError, context?: string): void {
		const extensionError = this.normalizeError(error, context);
		this.notifyListeners(extensionError);
		this.logError(extensionError);
	}

	private normalizeError(error: Error | ExtensionError, context?: string): ExtensionError {
		if (this.isExtensionError(error)) {
			return error;
		}

		return {
			name: error.name,
			message: error.message,
			stack: error.stack,
			severity: ErrorSeverity.ERROR,
			code: 'UNKNOWN_ERROR',
			details: { context },
			timestamp: new Date().toISOString(),
		};
	}

	private isExtensionError(error: any): error is ExtensionError {
		return 'severity' in error && 'code' in error;
	}

	private notifyListeners(error: ExtensionError): void {
		this.errorListeners.forEach((listener) => {
			try {
				listener(error);
			} catch (listenerError) {
				console.error('Error in error listener:', listenerError);
			}
		});
	}

	private logError(error: ExtensionError): void {
		console.error(`[${error.severity}][${error.code}] ${error.message}`, {
			timestamp: error.timestamp,
			details: error.details,
			stack: error.stack,
		});
	}
}

export function createError(
	message: string,
	code: string,
	severity: ErrorSeverity = ErrorSeverity.ERROR,
	details?: any,
): ExtensionError {
	return {
		name: 'ExtensionError',
		message,
		severity,
		code,
		details,
		timestamp: new Date().toISOString(),
		stack: new Error().stack,
	};
}

export function errorWrapper<T>(
	fn: (...args: any[]) => Promise<T> | T,
	errorCode: string,
	context?: string,
): (...args: any[]) => Promise<T> | T {
	// Check if the function is async (returns a Promise)
	const isAsync = fn.constructor.name === 'AsyncFunction' || fn.toString().includes('Promise');

	if (isAsync) {
		return async (...args: any[]): Promise<T> => {
			try {
				return await (fn(...args) as Promise<T>);
			} catch (error) {
				const handler = ExtensionErrorHandler.getInstance();
				if (error instanceof Error) {
					handler.handleError(
						createError(error.message, errorCode, ErrorSeverity.ERROR, { context, originalError: error }),
					);
				} else {
					handler.handleError(
						createError('An unknown error occurred', errorCode, ErrorSeverity.ERROR, {
							context,
							originalError: error,
						}),
					);
				}
				throw error;
			}
		};
	} else {
		// Handle synchronous functions
		return (...args: any[]): T => {
			try {
				return fn(...args) as T;
			} catch (error) {
				const handler = ExtensionErrorHandler.getInstance();
				if (error instanceof Error) {
					handler.handleError(
						createError(error.message, errorCode, ErrorSeverity.ERROR, { context, originalError: error }),
					);
				} else {
					handler.handleError(
						createError('An unknown error occurred', errorCode, ErrorSeverity.ERROR, {
							context,
							originalError: error,
						}),
					);
				}
				throw error;
			}
		};
	}
}

================
File: extension.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import { spawn, SpawnOptionsWithoutStdio } from 'child_process';
import * as path from 'path';
import { API_ENDPOINTS } from './config';
import { StorageService } from './storage';
import { ExtensionErrorHandler, ErrorSeverity, createError, errorWrapper } from './errorHandling';
import { registerChangeCommands } from './commands/changeCommands';
import { registerCheckpointCommands } from './commands/checkpointCommands';
import { registerAnnotationCommands } from './commands/annotationCommands';
import { registerImplementationCommands } from './commands/implementationCommands';
import { registerConflictCommands } from './commands/conflictCommands';
import { registerHistoryCommands } from './commands/historyCommands';
import { DiffService } from './services/diffService';
import { LanguageClient, LanguageClientOptions, ServerOptions, TransportKind } from 'vscode-languageclient/node';
import { registerLogger, traceError, traceLog, traceVerbose } from './common/log/logging';
import {
	checkVersion,
	getInterpreterDetails,
	initializePython,
	onDidChangePythonInterpreter,
	resolveInterpreter,
} from './common/python';
import { restartServer } from './common/server';
import { checkIfConfigurationChanged, getInterpreterFromSetting } from './common/settings';
import { loadServerDefaults } from './common/setup';
import { getLSClientTraceLevel } from './common/utilities';
import { createOutputChannel, onDidChangeConfiguration, registerCommand } from './common/vscodeapi';
import { CrewPanelProvider } from '../webview/src/panels/crew_panel/CrewPanelProvider';
import { StorageService as NewStorageService } from './services/storageService';
import * as fs from 'fs';

/**
 * Helper function to check if a workspace folder is open
 * @returns true if a workspace folder is open, false otherwise
 */
function hasWorkspaceFolder(): boolean {
	return vscode.workspace.workspaceFolders !== undefined && vscode.workspace.workspaceFolders.length > 0;
}

interface AgentPayload {
	name: string;
	role: string;
	backstory: string;
}

interface TaskPayload {
	description: string;
	assignedTo: string;
	name: string;
}

interface FeedbackPayload {
	agentId: string;
	actionType: string;
	feedback: Record<string, unknown>;
	context: Record<string, unknown>;
	accepted: boolean;
}

interface AutonomyPayload {
	agentId: string;
	taskType: string;
	autonomyLevel: number;
	supervisionRequirements: Record<string, unknown>;
}

interface FlowPayload {
	requirements: Record<string, unknown>;
	context: Record<string, unknown>;
}

interface WorkflowPayload {
	name: string;
	description: string;
	steps: Record<string, unknown>[];
	checkpoints: Record<string, unknown>[];
	requiredApprovals: string[];
}

interface CodePayload {
	requirements: string;
	context: Record<string, unknown>;
	language: string;
	framework?: string;
	outputFile: string;
}

interface RequirementsPayload {
	requirements: string;
}

interface AgentMessagePayload {
	agentId: string;
	message: string;
	isVPMessage?: boolean;
	isTeamMessage?: boolean;
	is_initialization?: boolean;
}

let lsClient: LanguageClient | undefined;
export const activate = errorWrapper(
	async (context: vscode.ExtensionContext): Promise<void> => {
		console.log('Activating Tribe extension');

		try {
			// Initialize error handler
			const errorHandler = ExtensionErrorHandler.getInstance();
			errorHandler.addErrorListener((error) => {
				vscode.window.showErrorMessage(`[${error.code}] ${error.message}`);
			});

			// Initialize storage service
			const storageService = StorageService.getInstance(context);

			// Initialize new services
			NewStorageService.getInstance(context);
			DiffService.getInstance();

			// Register command handlers
			registerChangeCommands(context);
			registerCheckpointCommands(context);
			registerAnnotationCommands(context);
			registerImplementationCommands(context);
			registerConflictCommands(context);
			registerHistoryCommands(context);

			// Use bundled Python environment
			const extensionPath = context.extensionPath;
			const pythonPath = vscode.Uri.joinPath(vscode.Uri.file(extensionPath), 'venv', 'bin', 'python').fsPath;
			traceLog(`Using Python interpreter: ${pythonPath}`);

			// This is required to get server name and module. This should be
			// the first thing that we do in this extension.
			try {
				const serverInfo = loadServerDefaults();
				const serverName = serverInfo.name;
				const serverId = serverInfo.module;

				// Setup logging
				const outputChannel = createOutputChannel(serverName);
				context.subscriptions.push(outputChannel, registerLogger(outputChannel));

				const changeLogLevel = async (c: vscode.LogLevel, g: vscode.LogLevel) => {
					const level = getLSClientTraceLevel(c, g);
					await lsClient?.setTrace(level);
				};

				context.subscriptions.push(
					outputChannel.onDidChangeLogLevel(async (e) => {
						await changeLogLevel(e, vscode.env.logLevel);
					}),
					vscode.env.onDidChangeLogLevel(async (e) => {
						await changeLogLevel(outputChannel.logLevel, e);
					}),
				);

				// Log Server information
				traceLog(`Name: ${serverInfo.name}`);
				traceLog(`Module: ${serverInfo.module}`);
				traceVerbose(`Full Server Info: ${JSON.stringify(serverInfo)}`);

				// Register CrewPanel commands
				const commands = [
					vscode.commands.registerCommand(
						'tribe.createTeam',
						errorWrapper(
							async (payload: { description: string }): Promise<any> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import json
import sys
import os
import asyncio
import uuid
from tribe import Tribe
from tribe.tools.agents import Agent

async def create_agent(tribe, spec):
    """Create an agent with error handling"""
    try:
        print(f"Creating agent with role: {spec['role']}", file=sys.stderr)
        
        # Create agent using Agent class directly
        agent = Agent(
            role=spec['role'],
            goal=spec['goal'],
            backstory=spec['backstory'],
            verbose=True,
            allow_delegation=True
        )
        
        # Add agent to tribe's crew
        tribe.crew.add_agent(agent)
        
        print(f"Agent creation successful for {spec['role']}", file=sys.stderr)
        return {
            'id': str(uuid.uuid4()),
            'role': spec['role'],
            'status': 'active'
        }
    except Exception as e:
        print(f"Error creating agent {spec['role']}: {str(e)}", file=sys.stderr)
        return None

async def main():
    try:
        # Get API endpoint from environment
        api_endpoint = os.environ.get('AI_API_ENDPOINT')
        if not api_endpoint:
            api_endpoint = "https://teqheaidyjmkjwkvkde65rfmo40epndv.lambda-url.eu-west-3.on.aws/"
            print(f"Using default API endpoint: {api_endpoint}", file=sys.stderr)
        else:
            print(f"Using API endpoint from environment: {api_endpoint}", file=sys.stderr)

        # Initialize Tribe with complete configuration
        config = {
            'api_endpoint': api_endpoint,
            'function_calling_llm': None,
            'manager_llm': None,
            'embedder': None,
            'planning_llm': None,
            'memory': None,
            'memory_config': None,
            'cache': True,
            'verbose': True,
            'process': 'hierarchical',
            'share_crew': True,
            'language': 'en',
            'full_output': False,
            'debug': True,
            'max_rpm': 60,
            'collaboration_mode': 'HYBRID',
            'task_execution_mode': {
                'allow_parallel': True,
                'allow_delegation': True,
                'max_concurrent_tasks': 10,
                'retry_failed_tasks': True,
                'max_retries': 3,
                'use_enhanced_scheduling': True
            }
        }
        
        print("Creating Tribe instance with config...", file=sys.stderr)
        tribe = await Tribe.create(config=config)
        
        print("Creating team...", file=sys.stderr)
        result = await tribe.crew.create_team(${JSON.stringify(payload.description)})
        print(f"Team creation result: {result}", file=sys.stderr)
        
        # Get the team ID from the result
        team_id = result.get('team', {}).get('id')
        
        # Create additional agents based on project requirements
        agent_specs = [
            {
                "name": "Project Manager",
                "role": "Project Manager",
                "goal": "Manage project tasks and coordinate team efforts",
                "backstory": "Expert in project management and team coordination"
            },
            {
                "name": "Developer",
                "role": "Developer",
                "goal": "Implement project features and write code",
                "backstory": "Skilled software developer with expertise in multiple languages"
            },
            {
                "name": "Architect",
                "role": "Architect",
                "goal": "Design system architecture and make technical decisions",
                "backstory": "Experienced software architect with focus on scalable systems"
            },
            {
                "role": "QA Engineer",
                "goal": "Ensure code quality and test coverage",
                "backstory": "Quality assurance expert with focus on automated testing"
            }
        ]
        
        # Create agents concurrently
        tasks = [create_agent(tribe, spec) for spec in agent_specs]
        created_agents = await asyncio.gather(*tasks)
        
        # Filter out failed agent creations and add to result
        created_agents = [agent for agent in created_agents if agent is not None]
        if created_agents:
            if 'team' in result:
                result['team']['agents'].extend(created_agents)
        
        print(f"Final team result: {result}", file=sys.stderr)
        print(json.dumps(result))
        
    except Exception as e:
        error_msg = f"Error creating team: {str(e)}"
        print(f"Exception details: {str(e.__class__.__name__)}: {str(e)}", file=sys.stderr)
        print(json.dumps({'error': error_msg}), file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    asyncio.run(main())
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											if (data.error) {
												reject(new Error(data.error));
											} else {
												resolve(data);
											}
										} catch (e) {
											reject(new Error('Failed to parse team creation response'));
										}
									});
								});
							},
							'CREATE_TEAM',
							'Create a new team of AI agents',
						),
					),

					vscode.commands.registerCommand(
						'tribe.initializeProject',
						errorWrapper(
							async (payload: {
								description: string;
							}): Promise<{ id: string; vision: string; response: string }> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}",
    json={
        "messages": [
            {
                "role": "system",
                "content": "You are the VP of Engineering, responsible for analyzing project requirements and creating the optimal team of AI agents, describing the initial set of tools, assigning tasks to the team, and creating initial workflow"
            },
            {
                "role": "user",
                "content": "${payload.description}"
            }
        ]
    }
)
print(json.dumps(response.json()))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											const response = data.choices?.[0]?.message?.content;
											resolve({
												id: Date.now().toString(),
												vision: payload.description,
												response,
											});
										} catch (e) {
											reject(new Error('Failed to initialize project'));
										}
									});
								});
							},
							'INITIALIZE_PROJECT',
							'Initialize a new project and create team',
						),
					),

					vscode.commands.registerCommand(
						'tribe.getAgents',
						errorWrapper(
							async (): Promise<any[]> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

try:
    response = requests.get("${API_ENDPOINTS.AI_API}/agents")
    data = response.json()
    print(json.dumps(data))
except Exception as e:
    print(json.dumps({"error": str(e), "agents": []}))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											// If we have mock data for testing, use it
											if (
												process.env.NODE_ENV === 'development' &&
												(!data.agents || data.agents.length === 0)
											) {
												resolve([
													{ id: 'agent-1', name: 'Developer', role: 'Developer' },
													{ id: 'agent-2', name: 'Designer', role: 'Designer' },
													{ id: 'agent-3', name: 'Product Manager', role: 'Product Manager' },
													{ id: 'agent-4', name: 'QA Engineer', role: 'QA Engineer' },
													{ id: 'agent-5', name: 'DevOps Engineer', role: 'DevOps Engineer' },
												]);
											} else {
												resolve(data.agents || []);
											}
										} catch (e) {
											console.error('Failed to parse agent list:', e);
											reject(new Error('Failed to parse agent list'));
										}
									});
								});
							},
							'GET_AGENTS',
							'Get list of available agents',
						),
					),

					vscode.commands.registerCommand(
						'tribe.createAgent',
						errorWrapper(
							async (
								payload: AgentPayload,
							): Promise<{
								id: string;
								name: string;
								role: string;
								status: string;
								backstory: string;
							}> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/agent/create",
    json={
        "name": "${payload.name}",
        "role": "${payload.role}",
        "backstory": "${payload.backstory}"
    }
)
print(json.dumps(response.json()))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											resolve(
												data.agent || {
													id: '',
													name: payload.name,
													role: payload.role,
													status: 'error',
													backstory: payload.backstory,
												},
											);
										} catch (e) {
											reject(new Error('Failed to parse agent creation response'));
										}
									});
								});
							},
							'CREATE_AGENT',
							'Create new agent',
						),
					),

					vscode.commands.registerCommand(
						'tribe.sendAgentMessage',
						errorWrapper(
							async (payload: AgentMessagePayload): Promise<any> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonScript = `
import requests, json, sys, uuid
from datetime import datetime
from tribe.core.dynamic import DynamicAgent
from tribe.tools.system_tools import SystemAccessManager
import asyncio

# Get payload parameters from command line arguments
agent_id = sys.argv[1]
message = sys.argv[2]
is_vp_message = sys.argv[3].lower() == "true"
is_team_message = sys.argv[4].lower() == "true"
is_initialization = sys.argv[5].lower() == "true"

async def check_system_access():
    """Check access to all systems"""
    system_manager = SystemAccessManager()
    agent = DynamicAgent(role="VP of Engineering")
    system_access = {}

    for system_name in ["learning_system", "project_management", "collaboration_tools"]:
        tool = system_manager.get_tool(system_name)
        if tool:
            access_info = await tool.execute(agent_role=agent.role)
            system_access[system_name] = access_info

    return system_access

try:
    # Get system access using asyncio
    system_access = asyncio.run(check_system_access())

    # Send request to API
    body = json.dumps({
        "messages": [
            {
                "role": "system",
                "content": f"You are responding as {agent_id}. Your responses should be based on the following verified system access:\\n{json.dumps(system_access, indent=2)}\\n\\nOnly claim access to systems that are verified above. If asked about system access, provide specific details from the verification results."
            },
            {
                "role": "user",
                "content": message
            }
        ],
        "agentId": agent_id,
        "isVPMessage": is_vp_message,
        "isTeamMessage": is_team_message,
        "is_initialization": is_initialization,
        "system_access": system_access
    })

    response = requests.post("${API_ENDPOINTS.AI_API}", data=body, headers={'Content-Type': 'application/json'}, timeout=30)
    
    if not response.ok:
        print(json.dumps({
            "type": "ERROR",
            "payload": f"API request failed: {response.status_code} - {response.text}"
        }))
        sys.exit(1)

    try:
        # Parse the response
        response_data = response.json()
        message_content = response_data.get("body", "No response received")
        if isinstance(message_content, str):
            message_content = message_content.strip('"')

        # Create response message
        print(json.dumps({
            "type": "MESSAGE_RESPONSE",
            "payload": {
                "id": str(uuid.uuid4()),
                "sender": agent_id,
                "content": message_content,
                "timestamp": datetime.now().isoformat(),
                "type": "agent",
                "targetAgent": agent_id,
                "isVPResponse": is_vp_message,
                "isManagerResponse": is_team_message,
                "isTeamMessage": is_team_message,
                "isSelfReferential": any(keyword in message_content.lower() for keyword in ["your role", "your capabilities", "what can you do", "who are you", "access", "system", "learning", "project management"]),
                "systemAccessVerified": True if agent_id == "VP of Engineering" else False,
                "availableTools": list(system_access.keys())
            }
        }))

    except Exception as e:
        print(json.dumps({
            "type": "ERROR",
            "payload": f"Failed to create response: {str(e)}"
        }))
        sys.exit(1)

except requests.RequestException as e:
    print(json.dumps({
        "type": "ERROR",
        "payload": f"Network error: {str(e)}"
    }))
    sys.exit(1)

except Exception as e:
    print(json.dumps({
        "type": "ERROR",
        "payload": f"Unexpected error: {str(e)}"
    }))
    sys.exit(1)
`;

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										pythonScript,
										payload.agentId,
										payload.message,
										String(payload.isVPMessage || false),
										String(payload.isTeamMessage || false),
										String(payload.is_initialization || false),
									],
									spawnOptions,
								);

								// Create a wrapper that handles loading states
								return new Promise((resolve, reject) => {
									// Generate a unique message ID for tracking
									const messageId = Date.now().toString();

									// Immediately resolve with a loading state
									const loadingIndicator = {
										type: 'LOADING_INDICATOR',
										payload: {
											id: messageId,
											sender: payload.agentId,
											targetAgent: payload.agentId,
											isVPResponse: payload.isVPMessage || false,
											isTeamMessage: payload.isTeamMessage || false,
											isLoading: true,
										},
									};

									console.log('Sending loading indicator:', loadingIndicator);
									resolve(loadingIndicator);

									let result = '';
									let error = '';

									// Collect the actual response
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});

									pythonProcess.stderr.on('data', (data: Buffer) => {
										error += data.toString();
										console.error(`Agent message error: ${data}`);
									});

									pythonProcess.on('close', async (code: number) => {
										if (code !== 0) {
											// Send error state
											console.log('Sending error message and hiding loading indicator');
											vscode.commands.executeCommand('tribe.updateMessage', {
												type: 'MESSAGE_RESPONSE',
												payload: {
													id: messageId, // Use the same ID for tracking
													sender: payload.agentId,
													content: `Error: ${error}`,
													timestamp: new Date().toISOString(),
													type: 'agent',
													targetAgent: payload.agentId,
													isError: true,
													isVPResponse: payload.isVPMessage || false,
													isTeamMessage: payload.isTeamMessage || false,
												},
												hideLoading: true,
											});
											return;
										}

										try {
											const response = JSON.parse(result);
											if (response.type === 'ERROR') {
												// Send error state
												console.log('Sending error response and hiding loading indicator');
												vscode.commands.executeCommand('tribe.updateMessage', {
													type: 'MESSAGE_RESPONSE',
													payload: {
														id: messageId, // Use the same ID for tracking
														sender: payload.agentId,
														content: response.payload,
														timestamp: new Date().toISOString(),
														type: 'agent',
														targetAgent: payload.agentId,
														isError: true,
														isVPResponse: payload.isVPMessage || false,
														isTeamMessage: payload.isTeamMessage || false,
													},
													hideLoading: true,
												});
											} else {
												// Ensure we have content before sending
												const content = response.payload?.content;
												if (!content || content.trim() === '') {
													console.log('Received empty content, sending error message');
													vscode.commands.executeCommand('tribe.updateMessage', {
														type: 'MESSAGE_RESPONSE',
														payload: {
															id: messageId, // Use the same ID for tracking
															sender: payload.agentId,
															content:
																"I apologize, but I couldn't generate a proper response. Please try again.",
															timestamp: new Date().toISOString(),
															type: 'agent',
															targetAgent: payload.agentId,
															isError: true,
															isVPResponse: payload.isVPMessage || false,
															isTeamMessage: payload.isTeamMessage || false,
														},
														hideLoading: true,
													});
													return;
												}

												// Send complete state and hide loading indicator
												console.log('Sending successful response and hiding loading indicator');
												vscode.commands.executeCommand('tribe.updateMessage', {
													...response,
													payload: {
														...response.payload,
														id: messageId, // Use the same ID for tracking
													},
													hideLoading: true,
												});
											}
										} catch (e) {
											// Send error state
											console.log('Sending parse error and hiding loading indicator');
											vscode.commands.executeCommand('tribe.updateMessage', {
												type: 'MESSAGE_RESPONSE',
												payload: {
													id: messageId, // Use the same ID for tracking
													sender: payload.agentId,
													content: `Failed to parse response: ${result}`,
													timestamp: new Date().toISOString(),
													type: 'agent',
													targetAgent: payload.agentId,
													isError: true,
													isVPResponse: payload.isVPMessage || false,
													isTeamMessage: payload.isTeamMessage || false,
												},
												hideLoading: true,
											});
										}
									});
								});
							},
							'SEND_AGENT_MESSAGE',
							'Send message to agent',
						),
					),

					vscode.commands.registerCommand(
						'tribe.createTask',
						errorWrapper(
							async (
								payload: TaskPayload,
							): Promise<{
								id: string;
								name: string;
								status: string;
								assignedTo: string;
								description: string;
							}> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/task/create",
    json={
        "type": "create_task",
        "description": "${payload.description}",
        "assigned_to": "${payload.assignedTo}",
        "name": "${payload.name}"
    }
)
print(json.dumps(response.json()))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											resolve(
												data.task || {
													id: '',
													name: payload.name,
													status: 'error',
													assignedTo: payload.assignedTo,
													description: payload.description,
												},
											);
										} catch (e) {
											reject(new Error('Failed to parse task creation response'));
										}
									});
								});
							},
							'CREATE_TASK',
							'Create new task',
						),
					),

					vscode.commands.registerCommand(
						'tribe.recordFeedback',
						errorWrapper(
							async (payload: FeedbackPayload): Promise<Record<string, unknown>> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/feedback/record",
    json={
        "type": "record_feedback",
        "agent_id": "${payload.agentId}",
        "action_type": "${payload.actionType}",
        "feedback": ${JSON.stringify(payload.feedback)},
        "context": ${JSON.stringify(payload.context)},
        "accepted": ${payload.accepted}
    }
)
print(json.dumps({ "result": response.json() }))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											resolve(
												data.result || {
													status: 'error',
													message: 'Failed to record feedback',
												},
											);
										} catch (e) {
											reject(new Error('Failed to parse feedback recording response'));
										}
									});
								});
							},
							'RECORD_FEEDBACK',
							'Record agent feedback',
						),
					),

					vscode.commands.registerCommand(
						'tribe.setAutonomyLevel',
						errorWrapper(
							async (payload: AutonomyPayload): Promise<Record<string, unknown>> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/autonomy/set",
    json={
        "type": "set_autonomy",
        "agent_id": "${payload.agentId}",
        "task_type": "${payload.taskType}",
        "autonomy_level": ${payload.autonomyLevel},
        "supervision_requirements": ${JSON.stringify(payload.supervisionRequirements)}
    }
)
print(json.dumps({ "result": response.json() }))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											resolve(
												data.result || {
													status: 'error',
													message: 'Failed to set autonomy level',
													agent_id: payload.agentId,
													autonomy_level: payload.autonomyLevel,
												},
											);
										} catch (e) {
											reject(new Error('Failed to parse autonomy level response'));
										}
									});
								});
							},
							'SET_AUTONOMY',
							'Set agent autonomy level',
						),
					),

					vscode.commands.registerCommand(
						'tribe.analyzeFlows',
						errorWrapper(
							async (): Promise<{ suggestions: Record<string, unknown>[] }> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.get("${API_ENDPOINTS.AI_API}/flows/analyze")
suggestions = response.json().get('suggestions', [])

print(json.dumps({"suggestions": suggestions}))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											resolve(
												data || {
													suggestions: [],
													status: 'error',
													message: 'Failed to analyze flows',
												},
											);
										} catch (e) {
											reject(new Error('Failed to parse flow analysis response'));
										}
									});
								});
							},
							'ANALYZE_FLOWS',
							'Analyze workflow flows',
						),
					),

					vscode.commands.registerCommand(
						'tribe.generateFlow',
						errorWrapper(
							async (
								payload: FlowPayload,
							): Promise<{
								flow_id: string;
								steps: string[];
								requirements: Record<string, unknown>;
								context: Record<string, unknown>;
							}> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/flow/generate",
    json={
        "requirements": ${JSON.stringify(payload.requirements)},
        "context": ${JSON.stringify(payload.context)}
    }
)

result = response.json()
flow_id = result.get('flow_id')
steps = result.get('steps', [])

output = {
    "flow_id": flow_id,
    "steps": steps,
    "requirements": payload.requirements,
    "context": payload.context
}

print(json.dumps(output))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											resolve(
												data || {
													flow_id: '',
													steps: [],
													requirements: payload.requirements,
													context: payload.context,
													status: 'error',
													message: 'Failed to generate flow',
												},
											);
										} catch (e) {
											reject(new Error('Failed to parse flow generation response'));
										}
									});
								});
							},
							'GENERATE_FLOW',
							'Generate new workflow flow',
						),
					),

					vscode.commands.registerCommand(
						'tribe.executeFlow',
						errorWrapper(
							async (payload: {
								flowId: string;
								initialState: Record<string, unknown>;
							}): Promise<{
								result: unknown;
								state: Record<string, unknown>;
								visualizations: unknown[];
							}> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/flow/execute",
    json={
        "flow_id": "${payload.flowId}",
        "initial_state": ${JSON.stringify(payload.initialState)}
    }
)

result = response.json()
output = {
    "result": result.get('result'),
    "state": result.get('state', {}),
    "visualizations": result.get('visualizations', []),
    "proposed_changes": {
        "files_to_modify": result.get('files_to_modify', []),
        "files_to_create": result.get('files_to_create', []),
        "files_to_delete": result.get('files_to_delete', [])
    }
}

print(json.dumps(output))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											resolve(
												data || {
													result: null,
													state: payload.initialState,
													visualizations: [],
													proposed_changes: {
														files_to_modify: [],
														files_to_create: [],
														files_to_delete: [],
													},
													status: 'error',
													message: 'Failed to execute flow',
												},
											);
										} catch (e) {
											reject(new Error('Failed to parse flow execution response'));
										}
									});
								});
							},
							'EXECUTE_FLOW',
							'Execute workflow flow',
						),
					),

					vscode.commands.registerCommand(
						'tribe.createWorkflow',
						errorWrapper(
							async (payload: WorkflowPayload): Promise<Record<string, unknown>> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/workflow/create",
    json={
        "name": "${payload.name}",
        "description": "${payload.description}",
        "steps": ${JSON.stringify(payload.steps)},
        "checkpoints": ${JSON.stringify(payload.checkpoints)},
        "required_approvals": ${JSON.stringify(payload.requiredApprovals)}
    }
)

print(json.dumps({"workflow": response.json()}))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											resolve(
												data.workflow || {
													id: '',
													name: payload.name,
													description: payload.description,
													steps: payload.steps,
													checkpoints: payload.checkpoints,
													required_approvals: payload.requiredApprovals,
													status: 'error',
													message: 'Failed to create workflow',
												},
											);
										} catch (e) {
											reject(new Error('Failed to parse workflow creation response'));
										}
									});
								});
							},
							'CREATE_WORKFLOW',
							'Create new workflow',
						),
					),

					vscode.commands.registerCommand(
						'tribe.generateCode',
						errorWrapper(
							async (payload: CodePayload): Promise<string> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/code/generate",
    json={
        "task_type": "code_generation",
        "requirements": ${JSON.stringify(payload.requirements)},
        "language": "${payload.language}",
        "framework": "${payload.framework || ''}",
        "output_file": "${payload.outputFile}"
    }
)

print(json.dumps({"result": response.json()}))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											if (data.result && data.result.code) {
												resolve(data.result.code);
											} else {
												resolve(
													`// Failed to generate code for requirements:\n// ${payload.requirements}\n// Language: ${payload.language}\n// Framework: ${payload.framework || 'none'}`,
												);
											}
										} catch (e) {
											reject(new Error('Failed to parse code generation response'));
										}
									});
								});
							},
							'GENERATE_CODE',
							'Generate code based on requirements',
						),
					),

					vscode.commands.registerCommand(
						'tribe.analyzeRequirements',
						errorWrapper(
							async (payload: RequirementsPayload): Promise<string> => {
								const tribePath = path.join(context.extensionPath, 'tribe');
								const tribeSrcPath = path.join(tribePath, 'src');
								const pythonPath = process.env.PYTHONPATH || '';
								const spawnOptions: SpawnOptionsWithoutStdio = {
									env: {
										...process.env,
										AI_API_ENDPOINT: API_ENDPOINTS.AI_API,
										PYTHONPATH: [tribePath, pythonPath].filter(Boolean).join(path.delimiter),
									},
								};

								const pythonProcess = spawn(
									'python',
									[
										'-c',
										`
import requests
import json

response = requests.post(
    "${API_ENDPOINTS.AI_API}/requirements/analyze",
    json={
        "requirements": ${JSON.stringify(payload.requirements)}
    }
)

print(json.dumps({"analysis": response.json().get('analysis')}))
`,
									],
									spawnOptions,
								);

								return new Promise((resolve, reject) => {
									let result = '';
									pythonProcess.stdout.on('data', (data: Buffer) => {
										result += data.toString();
									});
									pythonProcess.stderr.on('data', (data: Buffer) => {
										console.error(`Error: ${data}`);
									});
									pythonProcess.on('close', (code: number) => {
										if (code !== 0) {
											reject(new Error(`Process exited with code ${code}`));
											return;
										}
										try {
											const data = JSON.parse(result);
											if (data.analysis) {
												resolve(data.analysis);
											} else {
												resolve(
													`Analysis failed for requirements:\n${payload.requirements}\n\nPlease try again with more detailed requirements.`,
												);
											}
										} catch (e) {
											reject(new Error('Failed to parse requirements analysis response'));
										}
									});
								});
							},
							'ANALYZE_REQUIREMENTS',
							'Analyze project requirements',
						),
					),
					vscode.commands.registerCommand(
						'tribe.initializeTribe',
						errorWrapper(
							async (): Promise<TribeInitResult> => {
								console.log('Initializing tribe');
								try {
									// Check if workspace folder exists
									const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
									if (!workspaceFolder) {
										console.error('No workspace folder found');
										return {
											success: false,
											error: 'No workspace folder found',
											message:
												'Please open a folder in VS Code (File > Open Folder...) and try again.',
										};
									}

									// Initialize the tribe
									const storageService = StorageService.getInstance(context);
									// Create the .tribe directory in the workspace folder
									const tribeDir = path.join(workspaceFolder.uri.fsPath, '.tribe');
									if (!fs.existsSync(tribeDir)) {
										fs.mkdirSync(tribeDir, { recursive: true });
									}

									// Return success
									return {
										success: true,
										timestamp: new Date().toISOString(),
									};
								} catch (error) {
									console.error('Error initializing tribe:', error);
									return {
										success: false,
										error: error instanceof Error ? error.message : String(error),
										message: 'Failed to initialize Tribe. Please try again or contact support.',
									};
								}
							},
							'INITIALIZE_TRIBE',
							'Initialize the tribe environment',
						),
					),
				];

				context.subscriptions.push(...commands);

				// Register CrewPanel provider
				const crewPanelProvider = new CrewPanelProvider(context.extensionUri, context);
				context.subscriptions.push(
					vscode.window.registerWebviewViewProvider(CrewPanelProvider.viewType, crewPanelProvider),
				);

				// Show workspace folder warning if no folder is open
				if (!hasWorkspaceFolder()) {
					vscode.window.showWarningMessage(
						'Tribe extension requires an open workspace folder for full functionality. Some features may be limited.',
					);
				}

				// Register updateMessage command after crewPanelProvider is defined
				const updateMessageCommand = vscode.commands.registerCommand(
					'tribe.updateMessage',
					errorWrapper(
						async (response: any): Promise<void> => {
							console.log(
								'updateMessage called with type:',
								response.type,
								'hideLoading:',
								response.hideLoading,
							);

							// Ensure chain of command properties are preserved
							if (response.payload) {
								// Preserve VP and team message flags
								const isVPResponse = response.payload.isVPResponse;
								const isTeamMessage = response.payload.isTeamMessage;
								const teamId = response.payload.teamId;

								// Update the message status based on the response
								response.payload.status = response.payload.isLoading
									? 'loading'
									: response.payload.isError
										? 'error'
										: 'complete';

								// Ensure these properties are preserved in the update
								response.payload.isVPResponse = isVPResponse;
								response.payload.isTeamMessage = isTeamMessage;
								response.payload.teamId = teamId || (isTeamMessage ? 'root' : undefined);
							}

							// Use the already defined provider
							if (crewPanelProvider) {
								// Handle loading indicator separately
								if (response.type === 'LOADING_INDICATOR') {
									console.log('Handling loading indicator for agent:', response.payload?.sender);
									await crewPanelProvider._handleLoadingIndicator(response);
								} else if (response.hideLoading === true) {
									// Hide loading indicator and show the actual message
									console.log('Hiding loading indicator and showing message');
									await crewPanelProvider._hideLoadingIndicator();
									await crewPanelProvider._handleMessageUpdate(response);
								} else {
									// Regular message update
									console.log('Regular message update');
									await crewPanelProvider._handleMessageUpdate(response);
								}
							} else {
								console.error('crewPanelProvider not available for updateMessage');
							}
						},
						'UPDATE_MESSAGE',
						'Update message status in webview',
					),
				);
				context.subscriptions.push(updateMessageCommand);

				const runServer = errorWrapper(
					async () => {
						try {
							// First try to use the bundled Python that comes with the VS Code fork
							const extensionPath = context.extensionPath;
							const bundledPythonPath = vscode.Uri.joinPath(
								vscode.Uri.file(extensionPath),
								'venv',
								'bin',
								'python',
							).fsPath;

							// Check if the bundled Python exists
							try {
								const fs = require('fs');
								if (fs.existsSync(bundledPythonPath)) {
									traceLog(`Using bundled Python interpreter: ${bundledPythonPath}`);

									// Validate the Python interpreter before using it
									const resolvedInterpreter = await resolveInterpreter(bundledPythonPath);
									if (resolvedInterpreter) {
										traceLog(`Validated bundled Python interpreter: ${bundledPythonPath}`);

										// Set the interpreter in the settings
										await vscode.workspace
											.getConfiguration(serverId)
											.update(
												'interpreter',
												[bundledPythonPath],
												vscode.ConfigurationTarget.Global,
											);

										// Restart the server with the bundled Python
										lsClient = await restartServer(serverId, serverName, outputChannel, lsClient);
										return;
									} else {
										traceError(
											`Bundled Python interpreter validation failed: ${bundledPythonPath}`,
										);
									}
								} else {
									traceError(`Bundled Python not found at: ${bundledPythonPath}`);
								}
							} catch (error) {
								traceError(`Error checking bundled Python: ${error}`);
							}

							// If bundled Python is not available, try the configured interpreter
							const interpreter = getInterpreterFromSetting(serverId);
							if (interpreter && interpreter.length > 0) {
								// We don't need to check the version here since we're handling the case
								// when the Python extension is not available
								traceVerbose(
									`Using interpreter from ${serverInfo.module}.interpreter: ${interpreter.join(' ')}`,
								);
								lsClient = await restartServer(serverId, serverName, outputChannel, lsClient);
								return;
							}

							// As a last resort, try the Python extension
							try {
								const interpreterDetails = await getInterpreterDetails();
								if (interpreterDetails.path) {
									traceVerbose(
										`Using interpreter from Python extension: ${interpreterDetails.path.join(' ')}`,
									);
									lsClient = await restartServer(serverId, serverName, outputChannel, lsClient);
									return;
								}
							} catch (error) {
								traceError(`Error getting interpreter from Python extension: ${error}`);
							}

							// Show a warning but don't fail the extension activation
							traceError(
								'Python interpreter missing:\r\n' +
									'The bundled Python interpreter was not found.\r\n' +
									`[Option 1] Set an interpreter using "${serverId}.interpreter" setting.\r\n` +
									'[Option 2] Install the Python extension and select a Python interpreter.\r\n' +
									'Please use Python 3.8 or greater.',
							);

							vscode.window.showWarningMessage(
								'Tribe extension: Bundled Python interpreter not found. Some features will be limited. ' +
									'Please contact your administrator or set a Python 3.8+ interpreter manually.',
							);
						} catch (error) {
							// Log the error but don't fail the extension activation
							traceError('Error initializing Python server:', error);
							vscode.window.showWarningMessage(
								'Tribe extension: Failed to initialize Python server. Some features will be limited.',
							);
						}
					},
					'RUN_SERVER',
					'Server initialization',
				);

				context.subscriptions.push(
					onDidChangePythonInterpreter(
						errorWrapper(
							async () => {
								await runServer();
							},
							'INTERPRETER_CHANGE',
							'Python interpreter change handler',
						),
					),
					onDidChangeConfiguration(
						errorWrapper(
							async (e: vscode.ConfigurationChangeEvent) => {
								if (checkIfConfigurationChanged(e, serverId)) {
									await runServer();
								}
							},
							'CONFIG_CHANGE',
							'Configuration change handler',
						),
					),
					registerCommand(
						`${serverId}.restart`,
						errorWrapper(
							async () => {
								await runServer();
							},
							'SERVER_RESTART',
							'Server restart command',
						),
					),
				);

				setImmediate(async () => {
					try {
						// First check if we have a bundled Python
						const extensionPath = context.extensionPath;
						const bundledPythonPath = vscode.Uri.joinPath(
							vscode.Uri.file(extensionPath),
							'venv',
							'bin',
							'python',
						).fsPath;

						try {
							const fs = require('fs');
							if (fs.existsSync(bundledPythonPath)) {
								traceLog(`Found bundled Python at: ${bundledPythonPath}`);
								// Set the interpreter in the settings
								await vscode.workspace
									.getConfiguration(serverId)
									.update('interpreter', [bundledPythonPath], vscode.ConfigurationTarget.Global);
								await runServer();
								return;
							}
						} catch (error) {
							traceError(`Error checking bundled Python: ${error}`);
						}

						// If no bundled Python, check configured interpreter
						const interpreter = getInterpreterFromSetting(serverId);
						if (interpreter && interpreter.length > 0) {
							traceLog(`Using configured Python interpreter: ${interpreter.join(' ')}`);
							await runServer();
							return;
						}

						// As a last resort, try the Python extension
						try {
							traceLog(`Python extension loading`);
							await initializePython(context.subscriptions);
							traceLog(`Python extension loaded`);
							await runServer();
						} catch (error) {
							// Log the error but don't fail the extension activation
							traceError('Error initializing Python extension:', error);
							vscode.window.showWarningMessage(
								'Tribe extension: Python initialization failed. UI features will still be available, but AI functionality will be limited.',
							);
						}
					} catch (error) {
						// Log the error but don't fail the extension activation
						traceError('Error initializing Python:', error);
						vscode.window.showWarningMessage(
							'Tribe extension: Python initialization failed. UI features will still be available, but AI functionality will be limited.',
						);
					}
				});

				// Show activation message
				vscode.window.showInformationMessage('Tribe extension is now active!');
			} catch (e) {
				traceError('Failed to activate extension:', e);
				void vscode.window.showErrorMessage('Failed to activate Tribe extension.');
			}
		} catch (e) {
			traceError('Failed to activate extension:', e);
			void vscode.window.showErrorMessage('Failed to activate Tribe extension.');
		}
	},
	'EXTENSION_ACTIVATE',
	'Extension activation',
);

export const deactivate = errorWrapper(
	async (): Promise<void> => {
		console.log('Deactivating Tribe extension');
		if (lsClient) {
			await lsClient.stop();
		}
	},
	'EXTENSION_DEACTIVATE',
	'Extension deactivation',
);

/**
 * Interface for the result of tribe.initializeTribe command
 */
export interface TribeInitResult {
	success: boolean;
	error?: string;
	message?: string;
	timestamp?: string;
}

================
File: storage.ts
================
/* eslint-disable header/header */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { DiffUtils } from './diffUtils';

// Define interfaces for our data types
export interface FileChange {
	path: string;
	content: string;
	originalContent?: string;
	explanation?: string;
	timestamp?: string;
	hunks?: Array<{
		startLine: number;
		endLine: number;
		content: string;
		originalContent?: string;
		semanticGroup?: string;
	}>;
}

export interface ChangeGroup {
	id: string;
	title: string;
	description: string;
	agentId: string;
	agentName: string;
	timestamp: string;
	files: {
		modify: FileChange[];
		create: FileChange[];
		delete: string[];
	};
}

export interface Checkpoint {
	id: string;
	timestamp: string;
	description: string;
	changes: {
		modified: number;
		created: number;
		deleted: number;
	};
	// Reference to file containing the actual snapshot data
	snapshotPath: string;
	// List of change groups included in this checkpoint
	changeGroups?: string[];
	// Sub-checkpoints for more granular history
	subCheckpoints?: SubCheckpoint[];
}

// New interface for sub-checkpoints
export interface SubCheckpoint {
	id: string;
	timestamp: string;
	description: string;
	parentCheckpointId: string;
	changes: {
		modified: string[];
		created: string[];
		deleted: string[];
	};
}

export interface Annotation {
	id: string;
	content: string;
	author: {
		id: string;
		name: string;
		type: 'human' | 'agent';
	};
	timestamp: string;
	filePath?: string;
	lineStart?: number;
	lineEnd?: number;
	codeSnippet?: string;
	replies: Annotation[];
}

export interface Implementation {
	id: string;
	title: string;
	description: string;
	tradeoffs: {
		pros: string[];
		cons: string[];
	};
	files: {
		modify: FileChange[];
		create: FileChange[];
		delete: string[];
	};
}

export interface Conflict {
	id: string;
	type: 'merge' | 'dependency' | 'logic' | 'other';
	description: string;
	status: 'pending' | 'resolving' | 'resolved' | 'failed';
	files: string[];
	agentId?: string;
	agentName?: string;
	// New fields for conflict resolution
	resolutionStrategy?: 'auto' | 'manual';
	conflictingChanges?: {
		[agentId: string]: FileChange[];
	};
	resolvedChanges?: FileChange[];
	resolutionTimestamp?: string;
}

// New interface for change history
export interface ChangeHistoryEntry {
	id: string;
	timestamp: string;
	description: string;
	changeGroupId?: string;
	checkpointId?: string;
	changes: {
		modified: string[];
		created: string[];
		deleted: string[];
	};
	semanticGroups?: Record<string, string[]>;
}

/**
 * Service for managing storage of change groups, checkpoints, annotations, etc.
 */
export class StorageService {
	private context: vscode.ExtensionContext;
	private tribeDir: string | null = null;
	private static instance: StorageService | null = null;
	private changeHistory: ChangeHistoryEntry[] = [];

	private constructor(context: vscode.ExtensionContext) {
		this.context = context;
		this.initializeTribeDirectory();
	}

	/**
	 * Get the singleton instance of the StorageService
	 */
	public static getInstance(context?: vscode.ExtensionContext): StorageService {
		if (!StorageService.instance) {
			if (!context) {
				throw new Error('Context must be provided when initializing StorageService');
			}
			StorageService.instance = new StorageService(context);
		}
		return StorageService.instance;
	}

	/**
	 * Initialize the .tribe directory in the workspace
	 */
	private initializeTribeDirectory() {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (workspaceFolder) {
			this.tribeDir = path.join(workspaceFolder.uri.fsPath, '.tribe');
			if (!fs.existsSync(this.tribeDir)) {
				fs.mkdirSync(this.tribeDir, { recursive: true });
			}
		}
	}

	/**
	 * Save a change group to storage
	 */
	async saveChangeGroup(group: ChangeGroup): Promise<void> {
		const groups = await this.getChangeGroups();
		const existingIndex = groups.findIndex((g) => g.id === group.id);

		if (existingIndex >= 0) {
			groups[existingIndex] = group;
		} else {
			groups.push(group);
		}

		await this.context.workspaceState.update('changeGroups', groups);
	}

	/**
	 * Get all change groups from storage
	 */
	async getChangeGroups(): Promise<ChangeGroup[]> {
		return this.context.workspaceState.get('changeGroups', []);
	}

	/**
	 * Delete a change group from storage
	 */
	async deleteChangeGroup(groupId: string): Promise<void> {
		const groups = await this.getChangeGroups();
		const updatedGroups = groups.filter((g) => g.id !== groupId);
		await this.context.workspaceState.update('changeGroups', updatedGroups);
	}

	/**
	 * Save a checkpoint to storage
	 */
	async saveCheckpoint(checkpoint: Checkpoint, snapshotData: any): Promise<void> {
		if (!this.tribeDir) {
			throw new Error('No workspace folder found');
		}

		// Save checkpoint metadata
		const checkpoints = await this.getCheckpoints();
		const existingIndex = checkpoints.findIndex((c) => c.id === checkpoint.id);

		// Create snapshot file
		const snapshotPath = path.join(this.tribeDir, `checkpoint-${checkpoint.id}.json`);
		fs.writeFileSync(snapshotPath, JSON.stringify(snapshotData, null, 2), 'utf8');

		// Update checkpoint with snapshot path
		checkpoint.snapshotPath = snapshotPath;

		// Initialize sub-checkpoints array if not present
		if (!checkpoint.subCheckpoints) {
			checkpoint.subCheckpoints = [];
		}

		if (existingIndex >= 0) {
			checkpoints[existingIndex] = checkpoint;
		} else {
			checkpoints.push(checkpoint);
		}

		await this.context.workspaceState.update('checkpoints', checkpoints);

		// Add to change history
		const historyEntry: ChangeHistoryEntry = {
			id: `history-${Date.now()}`,
			timestamp: new Date().toISOString(),
			description: `Checkpoint: ${checkpoint.description}`,
			checkpointId: checkpoint.id,
			changes: {
				modified: Object.keys(snapshotData).filter(
					(path) =>
						checkpoint.changes.modified > 0 &&
						fs.existsSync(path) &&
						fs.readFileSync(path, 'utf8') !== snapshotData[path],
				),
				created: Object.keys(snapshotData).filter((path) => !fs.existsSync(path)),
				deleted: [],
			},
			semanticGroups: this.groupChangesBySemanticFeature(checkpoint.changes),
		};

		this.changeHistory.push(historyEntry);
		await this.saveChangeHistory();
	}

	/**
	 * Get all checkpoints from storage
	 */
	async getCheckpoints(): Promise<Checkpoint[]> {
		return this.context.workspaceState.get('checkpoints', []);
	}

	/**
	 * Get a checkpoint snapshot from storage
	 */
	async getCheckpointSnapshot(checkpointId: string): Promise<any> {
		const checkpoints = await this.getCheckpoints();
		const checkpoint = checkpoints.find((c) => c.id === checkpointId);

		if (!checkpoint || !checkpoint.snapshotPath) {
			throw new Error(`Checkpoint not found: ${checkpointId}`);
		}

		const snapshotData = fs.readFileSync(checkpoint.snapshotPath, 'utf8');
		return JSON.parse(snapshotData);
	}

	/**
	 * Delete a checkpoint from storage
	 */
	async deleteCheckpoint(checkpointId: string): Promise<void> {
		const checkpoints = await this.getCheckpoints();
		const checkpoint = checkpoints.find((c) => c.id === checkpointId);

		if (checkpoint && checkpoint.snapshotPath && fs.existsSync(checkpoint.snapshotPath)) {
			fs.unlinkSync(checkpoint.snapshotPath);
		}

		const updatedCheckpoints = checkpoints.filter((c) => c.id !== checkpointId);
		await this.context.workspaceState.update('checkpoints', updatedCheckpoints);
	}

	/**
	 * Save an annotation to storage
	 */
	async saveAnnotation(annotation: Annotation): Promise<void> {
		const annotations = await this.getAnnotations();
		const existingIndex = annotations.findIndex((a) => a.id === annotation.id);

		if (existingIndex >= 0) {
			annotations[existingIndex] = annotation;
		} else {
			annotations.push(annotation);
		}

		await this.context.workspaceState.update('annotations', annotations);
	}

	/**
	 * Get all annotations from storage
	 */
	async getAnnotations(): Promise<Annotation[]> {
		return this.context.workspaceState.get('annotations', []);
	}

	/**
	 * Delete an annotation from storage
	 */
	async deleteAnnotation(annotationId: string): Promise<void> {
		const annotations = await this.getAnnotations();

		// Helper function to recursively remove annotations
		const removeAnnotation = (items: Annotation[]): Annotation[] => {
			return items.filter((item) => {
				if (item.id === annotationId) {
					return false;
				}
				if (item.replies.length > 0) {
					item.replies = removeAnnotation(item.replies);
				}
				return true;
			});
		};

		const updatedAnnotations = removeAnnotation(annotations);
		await this.context.workspaceState.update('annotations', updatedAnnotations);
	}

	/**
	 * Add a reply to an annotation
	 */
	async addReplyToAnnotation(parentId: string, reply: Annotation): Promise<void> {
		const annotations = await this.getAnnotations();

		// Helper function to recursively find and update the parent annotation
		const addReply = (items: Annotation[]): boolean => {
			for (const item of items) {
				if (item.id === parentId) {
					item.replies.push(reply);
					return true;
				}
				if (item.replies.length > 0 && addReply(item.replies)) {
					return true;
				}
			}
			return false;
		};

		if (addReply(annotations)) {
			await this.context.workspaceState.update('annotations', annotations);
		} else {
			throw new Error(`Parent annotation not found: ${parentId}`);
		}
	}

	/**
	 * Save an alternative implementation to storage
	 */
	async saveImplementation(implementation: Implementation): Promise<void> {
		const implementations = await this.getImplementations();
		const existingIndex = implementations.findIndex((i) => i.id === implementation.id);

		if (existingIndex >= 0) {
			implementations[existingIndex] = implementation;
		} else {
			implementations.push(implementation);
		}

		await this.context.workspaceState.update('implementations', implementations);
	}

	/**
	 * Get all alternative implementations from storage
	 */
	async getImplementations(): Promise<Implementation[]> {
		return this.context.workspaceState.get('implementations', []);
	}

	/**
	 * Delete an alternative implementation from storage
	 */
	async deleteImplementation(implementationId: string): Promise<void> {
		const implementations = await this.getImplementations();
		const updatedImplementations = implementations.filter((i) => i.id !== implementationId);
		await this.context.workspaceState.update('implementations', updatedImplementations);
	}

	/**
	 * Save a conflict to storage
	 */
	async saveConflict(conflict: Conflict): Promise<void> {
		const conflicts = await this.getConflicts();
		const existingIndex = conflicts.findIndex((c) => c.id === conflict.id);

		if (existingIndex >= 0) {
			conflicts[existingIndex] = conflict;
		} else {
			conflicts.push(conflict);
		}

		await this.context.workspaceState.update('conflicts', conflicts);
	}

	/**
	 * Get all conflicts from storage
	 */
	async getConflicts(): Promise<Conflict[]> {
		return this.context.workspaceState.get('conflicts', []);
	}

	/**
	 * Delete a conflict from storage
	 */
	async deleteConflict(conflictId: string): Promise<void> {
		const conflicts = await this.getConflicts();
		const updatedConflicts = conflicts.filter((c) => c.id !== conflictId);
		await this.context.workspaceState.update('conflicts', updatedConflicts);
	}

	/**
	 * Create a snapshot of the current workspace
	 */
	async createWorkspaceSnapshot(): Promise<any> {
		if (!this.tribeDir) {
			throw new Error('No workspace folder found');
		}

		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			throw new Error('No workspace folder found');
		}

		const snapshot: Record<string, string> = {};

		// Helper function to recursively read files
		const readFilesRecursively = (dir: string, baseDir: string) => {
			const entries = fs.readdirSync(dir, { withFileTypes: true });

			for (const entry of entries) {
				const fullPath = path.join(dir, entry.name);
				const relativePath = path.relative(baseDir, fullPath);

				// Skip .tribe directory and node_modules
				if (entry.name === '.tribe' || entry.name === 'node_modules' || entry.name === '.git') {
					continue;
				}

				if (entry.isDirectory()) {
					readFilesRecursively(fullPath, baseDir);
				} else {
					try {
						const content = fs.readFileSync(fullPath, 'utf8');
						snapshot[relativePath] = content;
					} catch (error) {
						console.warn(`Failed to read file: ${fullPath}`, error);
					}
				}
			}
		};

		readFilesRecursively(workspaceFolder.uri.fsPath, workspaceFolder.uri.fsPath);

		return snapshot;
	}

	/**
	 * Restore workspace from a snapshot
	 */
	async restoreWorkspaceFromSnapshot(snapshot: Record<string, string>): Promise<void> {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			throw new Error('No workspace folder found');
		}

		for (const [relativePath, content] of Object.entries(snapshot)) {
			const fullPath = path.join(workspaceFolder.uri.fsPath, relativePath);
			const dirPath = path.dirname(fullPath);

			if (!fs.existsSync(dirPath)) {
				fs.mkdirSync(dirPath, { recursive: true });
			}

			fs.writeFileSync(fullPath, content, 'utf8');
		}
	}

	/**
	 * Calculate the diff between two snapshots using the Myers diff algorithm
	 */
	calculateDiff(
		oldSnapshot: Record<string, string>,
		newSnapshot: Record<string, string>,
	): {
		modified: string[];
		created: string[];
		deleted: string[];
		fileChanges: FileChange[];
	} {
		const modified: string[] = [];
		const created: string[] = [];
		const deleted: string[] = [];
		const fileChanges: FileChange[] = [];

		// Find modified and deleted files
		for (const path in oldSnapshot) {
			if (path in newSnapshot) {
				if (oldSnapshot[path] !== newSnapshot[path]) {
					modified.push(path);

					// Generate detailed file change with hunks
					const fileChange = DiffUtils.generateFileChange(path, oldSnapshot[path], newSnapshot[path]);

					fileChanges.push(fileChange);
				}
			} else {
				deleted.push(path);

				// Add deleted file to file changes
				fileChanges.push({
					path,
					content: '',
					originalContent: oldSnapshot[path],
					explanation: 'File deleted',
				});
			}
		}

		// Find created files
		for (const path in newSnapshot) {
			if (!(path in oldSnapshot)) {
				created.push(path);

				// Add created file to file changes
				fileChanges.push({
					path,
					content: newSnapshot[path],
					explanation: 'File created',
				});
			}
		}

		return { modified, created, deleted, fileChanges };
	}

	/**
	 * Group file changes by semantic features
	 */
	groupFileChangesByFeature(fileChanges: FileChange[]): Record<string, FileChange[]> {
		// Use DiffUtils to group changes by feature
		const groupedChanges: Record<string, FileChange[]> = {};

		// Group by file extension as a simple heuristic
		for (const change of fileChanges) {
			const ext = path.extname(change.path).toLowerCase();
			const featureGroup = ext ? ext.substring(1) : 'other'; // Remove the dot

			if (!groupedChanges[featureGroup]) {
				groupedChanges[featureGroup] = [];
			}

			groupedChanges[featureGroup].push(change);
		}

		// If we have hunks with semantic groups, use those for more detailed grouping
		const semanticGroups: Record<string, FileChange[]> = {};

		for (const change of fileChanges) {
			if (change.hunks) {
				for (const hunk of change.hunks) {
					if (hunk.semanticGroup) {
						if (!semanticGroups[hunk.semanticGroup]) {
							semanticGroups[hunk.semanticGroup] = [];
						}

						// Check if we already have this file change in this group
						const existingChange = semanticGroups[hunk.semanticGroup].find((c) => c.path === change.path);

						if (existingChange) {
							// Add the hunk to the existing change
							if (!existingChange.hunks) {
								existingChange.hunks = [];
							}
							existingChange.hunks.push(hunk);
						} else {
							// Create a new file change with just this hunk
							semanticGroups[hunk.semanticGroup].push({
								path: change.path,
								content: change.content,
								originalContent: change.originalContent,
								hunks: [hunk],
							});
						}
					}
				}
			}
		}

		// Merge the extension-based groups and semantic groups
		const result = { ...groupedChanges, ...semanticGroups };

		// If we have no semantic groups, add an "Uncategorized" group with all changes
		if (Object.keys(result).length === 0) {
			result['Uncategorized'] = [...fileChanges];
		}

		return result;
	}

	/**
	 * Create a sub-checkpoint within a parent checkpoint
	 */
	async createSubCheckpoint(
		parentCheckpointId: string,
		description: string,
		changes: { modified: string[]; created: string[]; deleted: string[] },
	): Promise<SubCheckpoint> {
		const checkpoints = await this.getCheckpoints();
		const parentIndex = checkpoints.findIndex((c) => c.id === parentCheckpointId);

		if (parentIndex < 0) {
			throw new Error(`Parent checkpoint not found: ${parentCheckpointId}`);
		}

		const subCheckpoint: SubCheckpoint = {
			id: `sub-${Date.now()}`,
			timestamp: new Date().toISOString(),
			description,
			parentCheckpointId,
			changes,
		};

		if (!checkpoints[parentIndex].subCheckpoints) {
			checkpoints[parentIndex].subCheckpoints = [];
		}

		checkpoints[parentIndex].subCheckpoints!.push(subCheckpoint);
		await this.context.workspaceState.update('checkpoints', checkpoints);

		// Add to change history
		const historyEntry: ChangeHistoryEntry = {
			id: `history-${Date.now()}`,
			timestamp: new Date().toISOString(),
			description: `Sub-checkpoint: ${description}`,
			checkpointId: parentCheckpointId,
			changes,
			semanticGroups: this.groupChangesBySemanticFeature({
				modified: changes.modified.length,
				created: changes.created.length,
				deleted: changes.deleted.length,
			}),
		};

		this.changeHistory.push(historyEntry);
		await this.saveChangeHistory();

		return subCheckpoint;
	}

	/**
	 * Revert to a specific sub-checkpoint
	 */
	async revertToSubCheckpoint(parentCheckpointId: string, subCheckpointId: string): Promise<void> {
		const checkpoints = await this.getCheckpoints();
		const parentCheckpoint = checkpoints.find((c) => c.id === parentCheckpointId);

		if (!parentCheckpoint || !parentCheckpoint.subCheckpoints) {
			throw new Error(`Parent checkpoint not found: ${parentCheckpointId}`);
		}

		const subCheckpoint = parentCheckpoint.subCheckpoints.find((sc) => sc.id === subCheckpointId);
		if (!subCheckpoint) {
			throw new Error(`Sub-checkpoint not found: ${subCheckpointId}`);
		}

		// Get the parent checkpoint snapshot
		const snapshotData = await this.getCheckpointSnapshot(parentCheckpointId);

		// Apply the changes from the sub-checkpoint
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			throw new Error('No workspace folder found');
		}

		// Restore files from the sub-checkpoint
		for (const filePath of subCheckpoint.changes.modified) {
			const fullPath = path.join(workspaceFolder.uri.fsPath, filePath);
			if (snapshotData[filePath] && fs.existsSync(path.dirname(fullPath))) {
				fs.writeFileSync(fullPath, snapshotData[filePath], 'utf8');
			}
		}

		for (const filePath of subCheckpoint.changes.created) {
			const fullPath = path.join(workspaceFolder.uri.fsPath, filePath);
			if (snapshotData[filePath]) {
				const dirPath = path.dirname(fullPath);
				if (!fs.existsSync(dirPath)) {
					fs.mkdirSync(dirPath, { recursive: true });
				}
				fs.writeFileSync(fullPath, snapshotData[filePath], 'utf8');
			}
		}

		for (const filePath of subCheckpoint.changes.deleted) {
			const fullPath = path.join(workspaceFolder.uri.fsPath, filePath);
			if (fs.existsSync(fullPath)) {
				fs.unlinkSync(fullPath);
			}
		}

		// Add to change history
		const historyEntry: ChangeHistoryEntry = {
			id: `history-${Date.now()}`,
			timestamp: new Date().toISOString(),
			description: `Reverted to sub-checkpoint: ${subCheckpoint.description}`,
			checkpointId: parentCheckpointId,
			changes: subCheckpoint.changes,
		};

		this.changeHistory.push(historyEntry);
		await this.saveChangeHistory();
	}

	/**
	 * Save change history to storage
	 */
	private async saveChangeHistory(): Promise<void> {
		await this.context.workspaceState.update('changeHistory', this.changeHistory);
	}

	/**
	 * Get change history from storage
	 */
	async getChangeHistory(): Promise<ChangeHistoryEntry[]> {
		const history = await this.context.workspaceState.get('changeHistory', []);
		this.changeHistory = history;
		return history;
	}

	/**
	 * Group changes by semantic feature
	 */
	private groupChangesBySemanticFeature(changes: {
		modified: number;
		created: number;
		deleted: number;
	}): Record<string, string[]> {
		// This is a placeholder implementation
		// In a real implementation, we would analyze the files and group them by semantic features
		return {
			Uncategorized: [`${changes.modified} modified, ${changes.created} created, ${changes.deleted} deleted`],
		};
	}

	/**
	 * Resolve a conflict automatically using agent-based resolution
	 */
	async resolveConflictAutomatically(conflictId: string): Promise<FileChange[]> {
		const conflicts = await this.getConflicts();
		const conflictIndex = conflicts.findIndex((c) => c.id === conflictId);

		if (conflictIndex < 0) {
			throw new Error(`Conflict not found: ${conflictId}`);
		}

		const conflict = conflicts[conflictIndex];

		if (!conflict.conflictingChanges || Object.keys(conflict.conflictingChanges).length === 0) {
			throw new Error('No conflicting changes to resolve');
		}

		// Set conflict status to resolving
		conflict.status = 'resolving';
		conflict.resolutionStrategy = 'auto';
		await this.saveConflict(conflict);

		// Merge the conflicting changes
		// This is a simple implementation that just takes the most recent changes
		// In a real implementation, we would use a more sophisticated algorithm
		const resolvedChanges: FileChange[] = [];
		const allChanges: FileChange[] = [];

		// Collect all changes from all agents
		for (const agentId in conflict.conflictingChanges) {
			allChanges.push(...conflict.conflictingChanges[agentId]);
		}

		// Group changes by file path
		const changesByFile: Record<string, FileChange[]> = {};
		for (const change of allChanges) {
			if (!changesByFile[change.path]) {
				changesByFile[change.path] = [];
			}
			changesByFile[change.path].push(change);
		}

		// For each file, merge the changes
		for (const filePath in changesByFile) {
			const fileChanges = changesByFile[filePath];

			// Sort by timestamp (assuming the most recent change is the best)
			fileChanges.sort((a, b) => {
				const aTime = new Date(a.timestamp || '0').getTime();
				const bTime = new Date(b.timestamp || '0').getTime();
				return bTime - aTime;
			});

			// Take the most recent change
			const mostRecentChange = fileChanges[0];

			// If there are hunks, merge them
			if (fileChanges.some((fc) => fc.hunks && fc.hunks.length > 0)) {
				// Collect all hunks
				const allHunks: Array<{
					startLine: number;
					endLine: number;
					content: string;
					originalContent?: string;
					semanticGroup?: string;
				}> = [];

				for (const change of fileChanges) {
					if (change.hunks) {
						allHunks.push(...change.hunks);
					}
				}

				// Sort hunks by start line
				allHunks.sort((a, b) => a.startLine - b.startLine);

				// Merge overlapping hunks
				const mergedHunks: Array<{
					startLine: number;
					endLine: number;
					content: string;
					originalContent?: string;
					semanticGroup?: string;
				}> = [];

				for (const hunk of allHunks) {
					// Check if this hunk overlaps with any existing merged hunk
					let overlapped = false;
					for (let i = 0; i < mergedHunks.length; i++) {
						const mergedHunk = mergedHunks[i];

						// Check for overlap
						if (
							(hunk.startLine >= mergedHunk.startLine && hunk.startLine <= mergedHunk.endLine) ||
							(hunk.endLine >= mergedHunk.startLine && hunk.endLine <= mergedHunk.endLine) ||
							(mergedHunk.startLine >= hunk.startLine && mergedHunk.startLine <= hunk.endLine)
						) {
							// Merge the hunks
							mergedHunk.startLine = Math.min(mergedHunk.startLine, hunk.startLine);
							mergedHunk.endLine = Math.max(mergedHunk.endLine, hunk.endLine);
							mergedHunk.content = hunk.content; // Take the content from the most recent hunk
							mergedHunk.originalContent = mergedHunk.originalContent || hunk.originalContent;
							overlapped = true;
							break;
						}
					}

					if (!overlapped) {
						mergedHunks.push({ ...hunk });
					}
				}

				// Create a new file change with the merged hunks
				mostRecentChange.hunks = mergedHunks;
			}

			resolvedChanges.push(mostRecentChange);
		}

		// Update the conflict with the resolved changes
		conflict.resolvedChanges = resolvedChanges;
		conflict.status = 'resolved';
		conflict.resolutionTimestamp = new Date().toISOString();
		await this.saveConflict(conflict);

		return resolvedChanges;
	}
}



================================================================
End of Codebase
================================================================
